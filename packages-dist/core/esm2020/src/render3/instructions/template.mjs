/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CONTAINERS, TEMPLATES } from '../../hydration/interfaces';
import { locateNextRNode } from '../../hydration/node_lookup_utils';
import { isNodeDisconnected, markRNodeAsClaimedForHydration } from '../../hydration/utils';
import { locateDehydratedViewsInContainer } from '../../hydration/views';
import { assertDefined } from '../../util/assert';
import { assertFirstCreatePass, assertRComment } from '../assert';
import { attachPatchData } from '../context_discovery';
import { registerPostOrderHooks } from '../hooks';
import { DEHYDRATED_VIEWS } from '../interfaces/container';
import { isDirectiveHost } from '../interfaces/type_checks';
import { HEADER_OFFSET, HYDRATION_INFO, RENDERER } from '../interfaces/view';
import { appendChild } from '../node_manipulation';
import { getCurrentTNode, getLView, getTView, isCurrentTNodeParent, isInSkipHydrationBlock, setCurrentTNode } from '../state';
import { getConstant } from '../util/view_utils';
import { addToViewTree, createDirectivesInstances, createLContainer, createTView, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData } from './shared';
function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const adjustedIndex = index + HEADER_OFFSET;
    const ngh = lView[HYDRATION_INFO];
    let ssrId = (ngh && ngh.data[TEMPLATES]?.[index]) || null;
    // TODO(pk): refactor getOrCreateTNode to have the "create" only version
    const tNode = getOrCreateTNode(tView, adjustedIndex, 4 /* TNodeType.Container */, tagName || null, getConstant(tViewConsts, attrsIndex), ssrId);
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    registerPostOrderHooks(tView, tNode);
    const embeddedTView = tNode.tViews = createTView(2 /* TViewType.Embedded */, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);
    if (tView.queries !== null) {
        tView.queries.template(tView, tNode);
        embeddedTView.queries = tView.queries.embeddedTView(tNode);
    }
    return tNode;
}
/**
 * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.
 *
 * <ng-template #foo>
 *    <div></div>
 * </ng-template>
 *
 * @param index The index of the container in the data array
 * @param templateFn Inline template
 * @param decls The number of nodes, local refs, and pipes for this template
 * @param vars The number of bindings for this template
 * @param tagName The name of the container element, if applicable
 * @param attrsIndex Index of template attributes in the `consts` array.
 * @param localRefs Index of the local references in the `consts` array.
 * @param localRefExtractor A function which extracts local-refs values from the template.
 *        Defaults to the current element associated with the local-ref.
 *
 * @codeGenApi
 */
export function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    const previousTNode = getCurrentTNode();
    const previousTNodeParent = isCurrentTNodeParent();
    const tNode = tView.firstCreatePass ?
        templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) :
        tView.data[adjustedIndex];
    const [isNewlyCreatedNode, comment, lContainer] = _locateOrCreateLContainerNode(tView, lView, tNode, adjustedIndex, previousTNode, previousTNodeParent);
    setCurrentTNode(tNode, false);
    isNewlyCreatedNode && appendChild(tView, lView, comment, tNode);
    attachPatchData(comment, lView);
    lView[adjustedIndex] = lContainer;
    addToViewTree(lView, lContainer);
    if (isDirectiveHost(tNode)) {
        createDirectivesInstances(tView, lView, tNode);
    }
    if (localRefsIndex != null) {
        saveResolvedLocalsInData(lView, tNode, localRefExtractor);
    }
}
let _locateOrCreateLContainerNode = (tView, lView, tNode, adjustedIndex, previousTNode, previousTNodeParent) => {
    const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');
    const lContainer = createLContainer(comment, lView, comment, tNode);
    return [true, comment, lContainer];
};
function locateOrCreateLContainerNodeImpl(tView, lView, tNode, adjustedIndex, previousTNode, previousTNodeParent) {
    let comment;
    let dehydratedViews = [];
    const ngh = lView[HYDRATION_INFO];
    const index = adjustedIndex - HEADER_OFFSET;
    const isCreating = !ngh || isInSkipHydrationBlock() || isNodeDisconnected(ngh, index);
    if (isCreating) {
        comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');
    }
    else {
        let currentRNode = locateNextRNode(ngh, tView, lView, tNode, previousTNode, previousTNodeParent);
        const nghContainer = ngh.data[CONTAINERS]?.[index];
        ngDevMode &&
            assertDefined(nghContainer, 'There is no hydration info available for this template');
        const [anchorRNode, views] = locateDehydratedViewsInContainer(currentRNode, nghContainer);
        comment = anchorRNode;
        dehydratedViews = views;
        ngDevMode && assertRComment(comment, 'Expecting a comment node in template instruction');
        ngDevMode && markRNodeAsClaimedForHydration(comment);
    }
    const lContainer = createLContainer(comment, lView, comment, tNode);
    if (ngh && dehydratedViews.length > 0) {
        lContainer[DEHYDRATED_VIEWS] = dehydratedViews;
    }
    return [isCreating, comment, lContainer];
}
export function enableLocateOrCreateLContainerNodeImpl() {
    _locateOrCreateLContainerNode = locateOrCreateLContainerNodeImpl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL2luc3RydWN0aW9ucy90ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFDSCxPQUFPLEVBQUMsVUFBVSxFQUFtQixTQUFTLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUNsRixPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFDbEUsT0FBTyxFQUFDLGtCQUFrQixFQUFFLDhCQUE4QixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDekYsT0FBTyxFQUFDLGdDQUFnQyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDdkUsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2hELE9BQU8sRUFBQyxxQkFBcUIsRUFBRSxjQUFjLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDaEUsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ3JELE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNoRCxPQUFPLEVBQUMsZ0JBQWdCLEVBQWEsTUFBTSx5QkFBeUIsQ0FBQztBQUlyRSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDMUQsT0FBTyxFQUFDLGFBQWEsRUFBRSxjQUFjLEVBQVMsUUFBUSxFQUFtQixNQUFNLG9CQUFvQixDQUFDO0FBQ3BHLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUNqRCxPQUFPLEVBQUMsZUFBZSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsc0JBQXNCLEVBQUUsZUFBZSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQzVILE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUUvQyxPQUFP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S0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwRSxJQUFJLEdBQUcsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUNyQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxlQUFlLENBQUM7S0FDaEQ7SUFDRCxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRUQsTUFBTSxVQUFVLHNDQUFzQztJQUNwRCw2QkFBNkIsR0FBRyxnQ0FBZ0MsQ0FBQztBQUNuRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge0NPTlRBSU5FUlMsIE5naFZpZXdJbnN0YW5jZSwgVEVNUExBVEVTfSBmcm9tICcuLi8uLi9oeWRyYXRpb24vaW50ZXJmYWNlcyc7XG5pbXBvcnQge2xvY2F0ZU5leHRSTm9kZX0gZnJvbSAnLi4vLi4vaHlkcmF0aW9uL25vZGVfbG9va3VwX3V0aWxzJztcbmltcG9ydCB7aXNOb2RlRGlzY29ubmVjdGVkLCBtYXJrUk5vZGVBc0NsYWltZWRGb3JIeWRyYXRpb259IGZyb20gJy4uLy4uL2h5ZHJhdGlvbi91dGlscyc7XG5pbXBvcnQge2xvY2F0ZURlaHlkcmF0ZWRWaWV3c0luQ29udGFpbmVyfSBmcm9tICcuLi8uLi9oeWRyYXRpb24vdmlld3MnO1xuaW1wb3J0IHthc3NlcnREZWZpbmVkfSBmcm9tICcuLi8uLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQge2Fzc2VydEZpcnN0Q3JlYXRlUGFzcywgYXNzZXJ0UkNvbW1lbnR9IGZyb20gJy4uL2Fzc2VydCc7XG5pbXBvcnQge2F0dGFjaFBhdGNoRGF0YX0gZnJvbSAnLi4vY29udGV4dF9kaXNjb3ZlcnknO1xuaW1wb3J0IHtyZWdpc3RlclBvc3RPcmRlckhvb2tzfSBmcm9tICcuLi9ob29rcyc7XG5pbXBvcnQge0RFSFlEUkFURURfVklFV1MsIExDb250YWluZXJ9IGZyb20gJy4uL2ludGVyZmFjZXMvY29udGFpbmVyJztcbmltcG9ydCB7Q29tcG9uZW50VGVtcGxhdGV9IGZyb20gJy4uL2ludGVyZmFjZXMvZGVmaW5pdGlvbic7XG5pbXBvcnQge0xvY2FsUmVmRXh0cmFjdG9yLCBUQXR0cmlidXRlcywgVENvbnRhaW5lck5vZGUsIFROb2RlLCBUTm9kZVR5cGV9IGZyb20gJy4uL2ludGVyZmFjZXMvbm9kZSc7XG5pbXBvcnQge1JDb21tZW50fSBmcm9tICcuLi9pbnRlcmZhY2VzL3JlbmRlcmVyX2RvbSc7XG5pbXBvcnQge2lzRGlyZWN0aXZlSG9zdH0gZnJvbSAnLi4vaW50ZXJmYWNlcy90eXBlX2NoZWNrcyc7XG5pbXBvcnQge0hFQURFUl9PRkZTRVQsIEhZRFJBVElPTl9JTkZPLCBMVmlldywgUkVOREVSRVIsIFRWaWV3LCBUVmlld1R5cGV9IGZyb20gJy4uL2ludGVyZmFjZXMvdmlldyc7XG5pbXBvcnQge2FwcGVuZENoaWxkfSBmcm9tICcuLi9ub2RlX21hbmlwdWxhdGlvbic7XG5pbXBvcnQge2dldEN1cnJlbnRUTm9kZSwgZ2V0TFZpZXcsIGdldFRWaWV3LCBpc0N1cnJlbnRUTm9kZVBhcmVudCwgaXNJblNraXBIeWRyYXRpb25CbG9jaywgc2V0Q3VycmVudFROb2RlfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQge2dldENvbnN0YW50fSBmcm9tICcuLi91dGlsL3ZpZXdfdXRpbHMnO1xuXG5pbXBvcnQge2FkZFRvVmlld1RyZWUsIGNyZWF0ZURpcmVjdGl2ZXNJbnN0YW5jZXMsIGNyZWF0ZUxDb250YWluZXIsIGNyZWF0ZVRWaWV3LCBnZXRPckNyZWF0ZVROb2RlLCByZXNvbHZlRGlyZWN0aXZlcywgc2F2ZVJlc29sdmVkTG9jYWxzSW5EYXRhfSBmcm9tICcuL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlRmlyc3RDcmVhdGVQYXNzKFxuICAgIGluZGV4OiBudW1iZXIsIHRWaWV3OiBUVmlldywgbFZpZXc6IExWaWV3LCB0ZW1wbGF0ZUZuOiBDb21wb25lbnRUZW1wbGF0ZTxhbnk+fG51bGwsXG4gICAgZGVjbHM6IG51bWJlciwgdmFyczogbnVtYmVyLCB0YWdOYW1lPzogc3RyaW5nfG51bGwsIGF0dHJzSW5kZXg/OiBudW1iZXJ8bnVsbCxcbiAgICBsb2NhbFJlZnNJbmRleD86IG51bWJlcnxudWxsKTogVENvbnRhaW5lck5vZGUge1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Rmlyc3RDcmVhdGVQYXNzKHRWaWV3KTtcbiAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5maXJzdENyZWF0ZVBhc3MrKztcbiAgY29uc3QgdFZpZXdDb25zdHMgPSB0Vmlldy5jb25zdHM7XG4gIGNvbnN0IGFkanVzdGVkSW5kZXggPSBpbmRleCArIEhFQURFUl9PRkZTRVQ7XG4gIGNvbnN0IG5naCA9IGxWaWV3W0hZRFJBVElPTl9JTkZPXTtcbiAgbGV0IHNzcklkID0gKG5naCAmJiBuZ2guZGF0YVtURU1QTEFURVNdPy5baW5kZXhdKSB8fCBudWxsO1xuICAvLyBUT0RPKHBrKTogcmVmYWN0b3IgZ2V0T3JDcmVhdGVUTm9kZSB0byBoYXZlIHRoZSBcImNyZWF0ZVwiIG9ubHkgdmVyc2lvblxuICBjb25zdCB0Tm9kZSA9IGdldE9yQ3JlYXRlVE5vZGUoXG4gICAgICB0VmlldywgYWRqdXN0ZWRJbmRleCwgVE5vZGVUeXBlLkNvbnRhaW5lciwgdGFnTmFtZSB8fCBudWxsLFxuICAgICAgZ2V0Q29uc3RhbnQ8VEF0dHJpYnV0ZXM+KHRWaWV3Q29uc3RzLCBhdHRyc0luZGV4KSwgc3NySWQpO1xuXG4gIHJlc29sdmVEaXJlY3RpdmVzKHRWaWV3LCBsVmlldywgdE5vZGUsIGdldENvbnN0YW50PHN0cmluZ1tdPih0Vmlld0NvbnN0cywgbG9jYWxSZWZzSW5kZXgpKTtcbiAgcmVnaXN0ZXJQb3N0T3JkZXJIb29rcyh0VmlldywgdE5vZGUpO1xuXG4gIGNvbnN0IGVtYmVkZGVkVFZpZXcgPSB0Tm9kZS50Vmlld3MgPSBjcmVhdGVUVmlldyhcbiAgICAgIFRWaWV3VHlwZS5FbWJlZGRlZCwgdE5vZGUsIHRlbXBsYXRlRm4sIGRlY2xzLCB2YXJzLCB0Vmlldy5kaXJlY3RpdmVSZWdpc3RyeSxcbiAgICAgIHRWaWV3LnBpcGVSZWdpc3RyeSwgbnVsbCwgdFZpZXcuc2NoZW1hcywgdFZpZXdDb25zdHMpO1xuXG4gIGlmICh0Vmlldy5xdWVyaWVzICE9PSBudWxsKSB7XG4gICAgdFZpZXcucXVlcmllcy50ZW1wbGF0ZSh0VmlldywgdE5vZGUpO1xuICAgIGVtYmVkZGVkVFZpZXcucXVlcmllcyA9IHRWaWV3LnF1ZXJpZXMuZW1iZWRkZWRUVmlldyh0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gdE5vZGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBMQ29udGFpbmVyIGZvciBhbiBuZy10ZW1wbGF0ZSAoZHluYW1pY2FsbHktaW5zZXJ0ZWQgdmlldyksIGUuZy5cbiAqXG4gKiA8bmctdGVtcGxhdGUgI2Zvbz5cbiAqICAgIDxkaXY+PC9kaXY+XG4gKiA8L25nLXRlbXBsYXRlPlxuICpcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNvbnRhaW5lciBpbiB0aGUgZGF0YSBhcnJheVxuICogQHBhcmFtIHRlbXBsYXRlRm4gSW5saW5lIHRlbXBsYXRlXG4gKiBAcGFyYW0gZGVjbHMgVGhlIG51bWJlciBvZiBub2RlcywgbG9jYWwgcmVmcywgYW5kIHBpcGVzIGZvciB0aGlzIHRlbXBsYXRlXG4gKiBAcGFyYW0gdmFycyBUaGUgbnVtYmVyIG9mIGJpbmRpbmdzIGZvciB0aGlzIHRlbXBsYXRlXG4gKiBAcGFyYW0gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQsIGlmIGFwcGxpY2FibGVcbiAqIEBwYXJhbSBhdHRyc0luZGV4IEluZGV4IG9mIHRlbXBsYXRlIGF0dHJpYnV0ZXMgaW4gdGhlIGBjb25zdHNgIGFycmF5LlxuICogQHBhcmFtIGxvY2FsUmVmcyBJbmRleCBvZiB0aGUgbG9jYWwgcmVmZXJlbmNlcyBpbiB0aGUgYGNvbnN0c2AgYXJyYXkuXG4gKiBAcGFyYW0gbG9jYWxSZWZFeHRyYWN0b3IgQSBmdW5jdGlvbiB3aGljaCBleHRyYWN0cyBsb2NhbC1yZWZzIHZhbHVlcyBmcm9tIHRoZSB0ZW1wbGF0ZS5cbiAqICAgICAgICBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgbG9jYWwtcmVmLlxuICpcbiAqIEBjb2RlR2VuQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1dGVtcGxhdGUoXG4gICAgaW5kZXg6IG51bWJlciwgdGVtcGxhdGVGbjogQ29tcG9uZW50VGVtcGxhdGU8YW55PnxudWxsLCBkZWNsczogbnVtYmVyLCB2YXJzOiBudW1iZXIsXG4gICAgdGFnTmFtZT86IHN0cmluZ3xudWxsLCBhdHRyc0luZGV4PzogbnVtYmVyfG51bGwsIGxvY2FsUmVmc0luZGV4PzogbnVtYmVyfG51bGwsXG4gICAgbG9jYWxSZWZFeHRyYWN0b3I/OiBMb2NhbFJlZkV4dHJhY3Rvcikge1xuICBjb25zdCBsVmlldyA9IGdldExWaWV3KCk7XG4gIGNvbnN0IHRWaWV3ID0gZ2V0VFZpZXcoKTtcbiAgY29uc3QgYWRqdXN0ZWRJbmRleCA9IGluZGV4ICsgSEVBREVSX09GRlNFVDtcblxuICBjb25zdCBwcmV2aW91c1ROb2RlID0gZ2V0Q3VycmVudFROb2RlKCk7XG4gIGNvbnN0IHByZXZpb3VzVE5vZGVQYXJlbnQgPSBpc0N1cnJlbnRUTm9kZVBhcmVudCgpO1xuXG4gIGNvbnN0IHROb2RlID0gdFZpZXcuZmlyc3RDcmVhdGVQYXNzID9cbiAgICAgIHRlbXBsYXRlRmlyc3RDcmVhdGVQYXNzKFxuICAgICAgICAgIGluZGV4LCB0VmlldywgbFZpZXcsIHRlbXBsYXRlRm4sIGRlY2xzLCB2YXJzLCB0YWdOYW1lLCBhdHRyc0luZGV4LCBsb2NhbFJlZnNJbmRleCkgOlxuICAgICAgdFZpZXcuZGF0YVthZGp1c3RlZEluZGV4XSBhcyBUQ29udGFpbmVyTm9kZTtcblxuICBjb25zdCBbaXNOZXdseUNyZWF0ZWROb2RlLCBjb21tZW50LCBsQ29udGFpbmVyXSA9IF9sb2NhdGVPckNyZWF0ZUxDb250YWluZXJOb2RlKFxuICAgICAgdFZpZXcsIGxWaWV3LCB0Tm9kZSwgYWRqdXN0ZWRJbmRleCwgcHJldmlvdXNUTm9kZSEsIHByZXZpb3VzVE5vZGVQYXJlbnQpO1xuXG4gIHNldEN1cnJlbnRUTm9kZSh0Tm9kZSwgZmFsc2UpO1xuICBpc05ld2x5Q3JlYXRlZE5vZGUgJiYgYXBwZW5kQ2hpbGQodFZpZXcsIGxWaWV3LCBjb21tZW50LCB0Tm9kZSk7XG4gIGF0dGFjaFBhdGNoRGF0YShjb21tZW50LCBsVmlldyk7XG5cbiAgbFZpZXdbYWRqdXN0ZWRJbmRleF0gPSBsQ29udGFpbmVyO1xuXG4gIGFkZFRvVmlld1RyZWUobFZpZXcsIGxDb250YWluZXIpO1xuXG4gIGlmIChpc0RpcmVjdGl2ZUhvc3QodE5vZGUpKSB7XG4gICAgY3JlYXRlRGlyZWN0aXZlc0luc3RhbmNlcyh0VmlldywgbFZpZXcsIHROb2RlKTtcbiAgfVxuXG4gIGlmIChsb2NhbFJlZnNJbmRleCAhPSBudWxsKSB7XG4gICAgc2F2ZVJlc29sdmVkTG9jYWxzSW5EYXRhKGxWaWV3LCB0Tm9kZSwgbG9jYWxSZWZFeHRyYWN0b3IpO1xuICB9XG59XG5cbmxldCBfbG9jYXRlT3JDcmVhdGVMQ29udGFpbmVyTm9kZTogdHlwZW9mIGxvY2F0ZU9yQ3JlYXRlTENvbnRhaW5lck5vZGVJbXBsID1cbiAgICAodFZpZXc6IFRWaWV3LCBsVmlldzogTFZpZXcsIHROb2RlOiBUTm9kZSwgYWRqdXN0ZWRJbmRleDogbnVtYmVyLCBwcmV2aW91c1ROb2RlOiBUTm9kZSxcbiAgICAgcHJldmlvdXNUTm9kZVBhcmVudDogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgY29tbWVudCA9IGxWaWV3W1JFTkRFUkVSXS5jcmVhdGVDb21tZW50KG5nRGV2TW9kZSA/ICdjb250YWluZXInIDogJycpO1xuICAgICAgY29uc3QgbENvbnRhaW5lciA9IGNyZWF0ZUxDb250YWluZXIoY29tbWVudCwgbFZpZXcsIGNvbW1lbnQsIHROb2RlKTtcbiAgICAgIHJldHVybiBbdHJ1ZSwgY29tbWVudCwgbENvbnRhaW5lcl07XG4gICAgfVxuXG5mdW5jdGlvbiBsb2NhdGVPckNyZWF0ZUxDb250YWluZXJOb2RlSW1wbChcbiAgICB0VmlldzogVFZpZXcsIGxWaWV3OiBMVmlldywgdE5vZGU6IFROb2RlLCBhZGp1c3RlZEluZGV4OiBudW1iZXIsIHByZXZpb3VzVE5vZGU6IFROb2RlLFxuICAgIHByZXZpb3VzVE5vZGVQYXJlbnQ6IGJvb2xlYW4pOiBbYm9vbGVhbiwgUkNvbW1lbnQsIExDb250YWluZXJdIHtcbiAgbGV0IGNvbW1lbnQ6IFJDb21tZW50O1xuICBsZXQgZGVoeWRyYXRlZFZpZXdzOiBOZ2hWaWV3SW5zdGFuY2VbXSA9IFtdO1xuICBjb25zdCBuZ2ggPSBsVmlld1tIWURSQVRJT05fSU5GT107XG4gIGNvbnN0IGluZGV4ID0gYWRqdXN0ZWRJbmRleCAtIEhFQURFUl9PRkZTRVQ7XG4gIGNvbnN0IGlzQ3JlYXRpbmcgPSAhbmdoIHx8IGlzSW5Ta2lwSHlkcmF0aW9uQmxvY2soKSB8fCBpc05vZGVEaXNjb25uZWN0ZWQobmdoLCBpbmRleCk7XG4gIGlmIChpc0NyZWF0aW5nKSB7XG4gICAgY29tbWVudCA9IGxWaWV3W1JFTkRFUkVSXS5jcmVhdGVDb21tZW50KG5nRGV2TW9kZSA/ICdjb250YWluZXInIDogJycpO1xuICB9IGVsc2Uge1xuICAgIGxldCBjdXJyZW50Uk5vZGUgPVxuICAgICAgICBsb2NhdGVOZXh0Uk5vZGUobmdoLCB0VmlldywgbFZpZXcsIHROb2RlLCBwcmV2aW91c1ROb2RlLCBwcmV2aW91c1ROb2RlUGFyZW50KTtcblxuICAgIGNvbnN0IG5naENvbnRhaW5lciA9IG5naC5kYXRhW0NPTlRBSU5FUlNdPy5baW5kZXhdITtcbiAgICBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYXNzZXJ0RGVmaW5lZChuZ2hDb250YWluZXIsICdUaGVyZSBpcyBubyBoeWRyYXRpb24gaW5mbyBhdmFpbGFibGUgZm9yIHRoaXMgdGVtcGxhdGUnKTtcblxuICAgIGNvbnN0IFthbmNob3JSTm9kZSwgdmlld3NdID0gbG9jYXRlRGVoeWRyYXRlZFZpZXdzSW5Db250YWluZXIoY3VycmVudFJOb2RlISwgbmdoQ29udGFpbmVyKTtcblxuICAgIGNvbW1lbnQgPSBhbmNob3JSTm9kZSBhcyBSQ29tbWVudDtcbiAgICBkZWh5ZHJhdGVkVmlld3MgPSB2aWV3cztcblxuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRSQ29tbWVudChjb21tZW50LCAnRXhwZWN0aW5nIGEgY29tbWVudCBub2RlIGluIHRlbXBsYXRlIGluc3RydWN0aW9uJyk7XG4gICAgbmdEZXZNb2RlICYmIG1hcmtSTm9kZUFzQ2xhaW1lZEZvckh5ZHJhdGlvbihjb21tZW50KTtcbiAgfVxuICBjb25zdCBsQ29udGFpbmVyID0gY3JlYXRlTENvbnRhaW5lcihjb21tZW50LCBsVmlldywgY29tbWVudCwgdE5vZGUpO1xuICBpZiAobmdoICYmIGRlaHlkcmF0ZWRWaWV3cy5sZW5ndGggPiAwKSB7XG4gICAgbENvbnRhaW5lcltERUhZRFJBVEVEX1ZJRVdTXSA9IGRlaHlkcmF0ZWRWaWV3cztcbiAgfVxuICByZXR1cm4gW2lzQ3JlYXRpbmcsIGNvbW1lbnQsIGxDb250YWluZXJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTG9jYXRlT3JDcmVhdGVMQ29udGFpbmVyTm9kZUltcGwoKSB7XG4gIF9sb2NhdGVPckNyZWF0ZUxDb250YWluZXJOb2RlID0gbG9jYXRlT3JDcmVhdGVMQ29udGFpbmVyTm9kZUltcGw7XG59XG4iXX0=