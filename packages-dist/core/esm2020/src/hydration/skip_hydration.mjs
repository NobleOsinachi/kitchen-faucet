/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertTNodeForLView } from '../render3/assert';
import { getTNodeFromLView } from '../render3/di';
import { DECLARATION_VIEW } from '../render3/interfaces/view';
export const SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';
/**
 * Helper function to walk up parent nodes using TNode data structure, crossing
 * view boundaries if needed, calling `predicateFn` at each level (with the current
 * TNode as an argument). The process stops when predicate return `true` for
 * the first time. If `predicateFn` never returned `true` after reaching the root
 * view, the function returns `false`.
 *
 * @param tNode
 * @param lView
 * @param predicateFn
 * @returns
 */
export function navigateParentTNodes(tNode, lView, predicateFn) {
    let currentTNode = tNode;
    let currentLView = lView;
    while (currentTNode !== null && currentLView !== null) {
        ngDevMode && assertTNodeForLView(currentTNode, currentLView);
        if (predicateFn(currentTNode)) {
            return currentTNode;
        }
        // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191
        let parentTNode = currentTNode.parent;
        // `TNode.parent` includes the parent within the current view only. If it doesn't exist,
        // it means that we've hit the view boundary and we need to go up to the next view.
        if (!parentTNode) {
            // Keep going up the tree.
            parentTNode = getTNodeFromLView(currentLView);
            currentLView = currentLView[DECLARATION_VIEW];
        }
        currentTNode = parentTNode;
    }
    return null;
}
export function hasNgSkipHydrationAttr(tNode) {
    // TODO: we need to iterate over `tNode.mergedAttrs` better
    // to avoid cases when `ngSkipHydration` is an attribute value,
    // e.g. `<div title="ngSkipHydration"></div>`.
    return !!tNode.mergedAttrs?.includes(SKIP_HYDRATION_ATTR_NAME);
}
export function isInSkipHydrationBlock(tNode, lView) {
    const foundTNode = navigateParentTNodes(tNode, lView, hasNgSkipHydrationAttr);
    // We are in a skip hydration block when:
    // - we have a TNode
    // - the tNode is different than the root node
    return foundTNode !== null && foundTNode !== tNode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2tpcF9oeWRyYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oeWRyYXRpb24vc2tpcF9oeWRyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWhELE9BQU8sRUFBQyxnQkFBZ0IsRUFBUSxNQUFNLDRCQUE0QixDQUFDO0FBRW5FLE1BQU0sQ0FBQyxNQUFNLHdCQUF3QixHQUFHLGlCQUFpQixDQUFDO0FBRTFEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUNoQyxLQUFZLEVBQUUsS0FBWSxFQUFFLFdBQXNDO0lBQ3BFLElBQUksWUFBWSxHQUFlLEtBQUssQ0FBQztJQUNyQyxJQUFJLFlBQVksR0FBZSxLQUFLLENBQUM7SUFFckMsT0FBTyxZQUFZLEtBQUssSUFBSSxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUU7UUFDckQsU0FBUyxJQUFJLG1CQUFtQixDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUU3RCxJQUFJLFdBQVcsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUM3QixPQUFPLFlBQVksQ0FBQztTQUNyQjtRQUVELDZGQUE2RjtRQUM3RixJQUFJLFdBQVcsR0FBcUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUV4RSx3RkFBd0Y7UUFDeEYsbUZBQW1GO1FBQ25GLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsMEJBQTBCO1lBQzFCLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUM5QyxZQUFZLEdBQUcsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDL0M7UUFFRCxZQUFZLEdBQUcsV0FBVyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEtBQVk7SUFDakQsMkRBQTJEO0lBQzNELCtEQUErRDtJQUMvRCw4Q0FBOEM7SUFDOUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEtBQVksRUFBRSxLQUFZO0lBQy9ELE1BQU0sVUFBVSxHQUFHLG9CQUFvQixDQUFDLEtBQWMsRUFBRSxLQUFLLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUN2Rix5Q0FBeUM7SUFDekMsb0JBQW9CO0lBQ3BCLDhDQUE4QztJQUM5QyxPQUFPLFVBQVUsS0FBSyxJQUFJLElBQUksVUFBVSxLQUFLLEtBQUssQ0FBQztBQUNyRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7YXNzZXJ0VE5vZGVGb3JMVmlld30gZnJvbSAnLi4vcmVuZGVyMy9hc3NlcnQnO1xuaW1wb3J0IHtnZXRUTm9kZUZyb21MVmlld30gZnJvbSAnLi4vcmVuZGVyMy9kaSc7XG5pbXBvcnQge1RDb250YWluZXJOb2RlLCBURWxlbWVudE5vZGUsIFROb2RlfSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvbm9kZSc7XG5pbXBvcnQge0RFQ0xBUkFUSU9OX1ZJRVcsIExWaWV3fSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvdmlldyc7XG5cbmV4cG9ydCBjb25zdCBTS0lQX0hZRFJBVElPTl9BVFRSX05BTUUgPSAnbmdTa2lwSHlkcmF0aW9uJztcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gd2FsayB1cCBwYXJlbnQgbm9kZXMgdXNpbmcgVE5vZGUgZGF0YSBzdHJ1Y3R1cmUsIGNyb3NzaW5nXG4gKiB2aWV3IGJvdW5kYXJpZXMgaWYgbmVlZGVkLCBjYWxsaW5nIGBwcmVkaWNhdGVGbmAgYXQgZWFjaCBsZXZlbCAod2l0aCB0aGUgY3VycmVudFxuICogVE5vZGUgYXMgYW4gYXJndW1lbnQpLiBUaGUgcHJvY2VzcyBzdG9wcyB3aGVuIHByZWRpY2F0ZSByZXR1cm4gYHRydWVgIGZvclxuICogdGhlIGZpcnN0IHRpbWUuIElmIGBwcmVkaWNhdGVGbmAgbmV2ZXIgcmV0dXJuZWQgYHRydWVgIGFmdGVyIHJlYWNoaW5nIHRoZSByb290XG4gKiB2aWV3LCB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBwYXJhbSB0Tm9kZVxuICogQHBhcmFtIGxWaWV3XG4gKiBAcGFyYW0gcHJlZGljYXRlRm5cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0ZVBhcmVudFROb2RlcyhcbiAgICB0Tm9kZTogVE5vZGUsIGxWaWV3OiBMVmlldywgcHJlZGljYXRlRm46ICh0Tm9kZTogVE5vZGUpID0+IGJvb2xlYW4pOiBUTm9kZXxudWxsIHtcbiAgbGV0IGN1cnJlbnRUTm9kZTogVE5vZGV8bnVsbCA9IHROb2RlO1xuICBsZXQgY3VycmVudExWaWV3OiBMVmlld3xudWxsID0gbFZpZXc7XG5cbiAgd2hpbGUgKGN1cnJlbnRUTm9kZSAhPT0gbnVsbCAmJiBjdXJyZW50TFZpZXcgIT09IG51bGwpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0VE5vZGVGb3JMVmlldyhjdXJyZW50VE5vZGUsIGN1cnJlbnRMVmlldyk7XG5cbiAgICBpZiAocHJlZGljYXRlRm4oY3VycmVudFROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRUTm9kZTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYW4gZXhwbGljaXQgdHlwZSBkdWUgdG8gYSBUUyBidWc6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzMxOTFcbiAgICBsZXQgcGFyZW50VE5vZGU6IFRFbGVtZW50Tm9kZXxUQ29udGFpbmVyTm9kZXxudWxsID0gY3VycmVudFROb2RlLnBhcmVudDtcblxuICAgIC8vIGBUTm9kZS5wYXJlbnRgIGluY2x1ZGVzIHRoZSBwYXJlbnQgd2l0aGluIHRoZSBjdXJyZW50IHZpZXcgb25seS4gSWYgaXQgZG9lc24ndCBleGlzdCxcbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlJ3ZlIGhpdCB0aGUgdmlldyBib3VuZGFyeSBhbmQgd2UgbmVlZCB0byBnbyB1cCB0byB0aGUgbmV4dCB2aWV3LlxuICAgIGlmICghcGFyZW50VE5vZGUpIHtcbiAgICAgIC8vIEtlZXAgZ29pbmcgdXAgdGhlIHRyZWUuXG4gICAgICBwYXJlbnRUTm9kZSA9IGdldFROb2RlRnJvbUxWaWV3KGN1cnJlbnRMVmlldyk7XG4gICAgICBjdXJyZW50TFZpZXcgPSBjdXJyZW50TFZpZXdbREVDTEFSQVRJT05fVklFV107XG4gICAgfVxuXG4gICAgY3VycmVudFROb2RlID0gcGFyZW50VE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc05nU2tpcEh5ZHJhdGlvbkF0dHIodE5vZGU6IFROb2RlKTogYm9vbGVhbiB7XG4gIC8vIFRPRE86IHdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGB0Tm9kZS5tZXJnZWRBdHRyc2AgYmV0dGVyXG4gIC8vIHRvIGF2b2lkIGNhc2VzIHdoZW4gYG5nU2tpcEh5ZHJhdGlvbmAgaXMgYW4gYXR0cmlidXRlIHZhbHVlLFxuICAvLyBlLmcuIGA8ZGl2IHRpdGxlPVwibmdTa2lwSHlkcmF0aW9uXCI+PC9kaXY+YC5cbiAgcmV0dXJuICEhdE5vZGUubWVyZ2VkQXR0cnM/LmluY2x1ZGVzKFNLSVBfSFlEUkFUSU9OX0FUVFJfTkFNRSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luU2tpcEh5ZHJhdGlvbkJsb2NrKHROb2RlOiBUTm9kZSwgbFZpZXc6IExWaWV3KTogYm9vbGVhbiB7XG4gIGNvbnN0IGZvdW5kVE5vZGUgPSBuYXZpZ2F0ZVBhcmVudFROb2Rlcyh0Tm9kZSBhcyBUTm9kZSwgbFZpZXcsIGhhc05nU2tpcEh5ZHJhdGlvbkF0dHIpO1xuICAvLyBXZSBhcmUgaW4gYSBza2lwIGh5ZHJhdGlvbiBibG9jayB3aGVuOlxuICAvLyAtIHdlIGhhdmUgYSBUTm9kZVxuICAvLyAtIHRoZSB0Tm9kZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcm9vdCBub2RlXG4gIHJldHVybiBmb3VuZFROb2RlICE9PSBudWxsICYmIGZvdW5kVE5vZGUgIT09IHROb2RlO1xufVxuIl19