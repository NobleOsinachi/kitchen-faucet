/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { PLATFORM_ID } from '../application_tokens';
import { ViewEncapsulation } from '../metadata/view';
import { getDocument } from '../render3/interfaces/document';
import { isRootView } from '../render3/interfaces/type_checks';
import { HEADER_OFFSET } from '../render3/interfaces/view';
import { IS_HYDRATION_FEATURE_ENABLED } from './api';
import { decompressNghInfo } from './compression';
import { NODES } from './interfaces';
export const NGH_ATTR_NAME = 'ngh';
export const EMPTY_TEXT_NODE_COMMENT = 'ngetn';
export const TEXT_NODE_SEPARATOR_COMMENT = 'ngtns';
/**
 * Reference to a function that reads `ngh` attribute from
 * a given RNode. Returns `null` by default, when hydration is not enabled.
 * @param rNode
 */
let _retrieveNghInfoImpl = (rNode) => null;
function retrieveNghInfoImpl(rNode) {
    let nghInfo = null;
    const nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
    if (nghAttrValue != null) {
        nghInfo = nghAttrValue !== '' ? decompressNghInfo(nghAttrValue) : {};
        nghInfo.firstChild = rNode.firstChild;
        rNode.removeAttribute(NGH_ATTR_NAME);
        // Note: don't check whether this node was claimed for hydration,
        // because this node might've been previously claimed while processing
        // template instructions.
        ngDevMode && markRNodeAsClaimedForHydration(rNode, /* checkIfAlreadyClaimed */ false);
        ngDevMode && ngDevMode.hydratedComponents++;
    }
    return nghInfo;
}
export function enableRetrieveNghInfoImpl() {
    _retrieveNghInfoImpl = retrieveNghInfoImpl;
}
export function retrieveNghInfo(rNode) {
    return _retrieveNghInfoImpl(rNode);
}
export function getComponentLView(viewRef) {
    let lView = viewRef._lView;
    if (isRootView(lView)) {
        lView = lView[HEADER_OFFSET];
    }
    return lView;
}
export function processTextNodeMarkersBeforeHydration(node) {
    const doc = getDocument();
    const commentIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
        acceptNode(node) {
            const content = node.textContent;
            const isTextNodeMarker = content === EMPTY_TEXT_NODE_COMMENT || content === TEXT_NODE_SEPARATOR_COMMENT;
            return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
    });
    let currentNode;
    while (currentNode = commentIterator.nextNode()) {
        if (currentNode.textContent === EMPTY_TEXT_NODE_COMMENT) {
            currentNode.replaceWith(doc.createTextNode(''));
        }
        else {
            currentNode.remove();
        }
    }
}
export function locateHostElementImpl(renderer, elementOrSelector, encapsulation, injector) {
    const isHydrationEnabled = injector.get(IS_HYDRATION_FEATURE_ENABLED, false);
    // FIXME: this is a fix to the problem that happens in tests :(
    // We load extra code from `provideHydrationSupport` fn, but it is retained
    // throughout the execution of all tests, thus also making it into
    // SSR code path. We should investigate how to avoid this check here.
    const isBrowser = injector.get(PLATFORM_ID) === 'browser';
    const preserveContent = (isBrowser && isHydrationEnabled) || encapsulation === ViewEncapsulation.ShadowDom;
    const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
    if (isHydrationEnabled) {
        processTextNodeMarkersBeforeHydration(rootElement);
    }
    return rootElement;
}
;
// TODO: consider using WeakMap instead.
export function markRNodeAsClaimedForHydration(node, checkIfAlreadyClaimed = true) {
    if (!ngDevMode) {
        throw new Error('Calling `claimNode` in prod mode is not supported and likely a mistake.');
    }
    if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
        throw new Error('Trying to claim a node, which was claimed already.');
    }
    node.__claimed = true;
    ngDevMode.hydratedNodes++;
}
export function isRNodeClaimedForHydration(node) {
    return !!node.__claimed;
}
/**
 * Special marker that indicates that this node was dropped
 * during content projection. We need to re-create this node
 * from scratch during hydration.
 */
export const DROPPED_PROJECTED_NODE = 'd';
/**
 * Checks whether a node is annotated as "disconnected", i.e. not present
 * in live DOM at serialization time.
 */
export function isNodeDisconnected(hydrationInfo, index) {
    return hydrationInfo[NODES]?.[index] === DROPPED_PROJECTED_NODE;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oeWRyYXRpb24vdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBR2xELE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQ25ELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUczRCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFDN0QsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBRXpELE9BQU8sRUFBQyw0QkFBNEIsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUNuRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDaEQsT0FBTyxFQUFTLEtBQUssRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUUzQyxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBQ25DLE1BQU0sQ0FBQyxNQUFNLHVCQUF1QixHQUFHLE9BQU8sQ0FBQztBQUMvQyxNQUFNLENBQUMsTUFBTSwyQkFBMkIsR0FBRyxPQUFPLENBQUM7QUFFbkQ7Ozs7R0FJRztBQUNILElBQUksb0JBQW9CLEdBQStCLENBQUMsS0FBZSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUM7QUFFakYsU0FBUyxtQkFBbUIsQ0FBQyxLQUFlO0lBQzFDLElBQUksT0FBTyxHQUFnQixJQUFJLENBQUM7SUFDaEMsTUFBTSxZQUFZLEdBQUksS0FBcUIsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDeEUsSUFBSSxZQUFZLElBQUksSUFBSSxFQUFFO1FBQ3hCLE9BQU8sR0FBRyxZQUFZLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIs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VUFBVSw4QkFBOEIsQ0FBQyxJQUFXLEVBQUUscUJBQXFCLEdBQUcsSUFBSTtJQUN0RixJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDO0tBQzVGO0lBQ0QsSUFBSSxxQkFBcUIsSUFBSSwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUM3RCxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDdkU7SUFDQSxJQUFvQixDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFDdkMsU0FBUyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQzVCLENBQUM7QUFFRCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsSUFBVztJQUNwRCxPQUFPLENBQUMsQ0FBRSxJQUFvQixDQUFDLFNBQVMsQ0FBQztBQUMzQyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLEdBQUcsQ0FBQztBQUUxQzs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsYUFBcUIsRUFBRSxLQUFhO0lBQ3JFLE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssc0JBQXNCLENBQUM7QUFDbEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1BMQVRGT1JNX0lEfSBmcm9tICcuLi9hcHBsaWNhdGlvbl90b2tlbnMnO1xuaW1wb3J0IHtJbmplY3Rvcn0gZnJvbSAnLi4vZGkvaW5qZWN0b3InO1xuaW1wb3J0IHtWaWV3UmVmfSBmcm9tICcuLi9saW5rZXInO1xuaW1wb3J0IHtWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnLi4vbWV0YWRhdGEvdmlldyc7XG5pbXBvcnQge2dldERvY3VtZW50fSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvZG9jdW1lbnQnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi4vcmVuZGVyMy9pbnRlcmZhY2VzL3JlbmRlcmVyJztcbmltcG9ydCB7UkVsZW1lbnQsIFJOb2RlfSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvcmVuZGVyZXJfZG9tJztcbmltcG9ydCB7aXNSb290Vmlld30gZnJvbSAnLi4vcmVuZGVyMy9pbnRlcmZhY2VzL3R5cGVfY2hlY2tzJztcbmltcG9ydCB7SEVBREVSX09GRlNFVH0gZnJvbSAnLi4vcmVuZGVyMy9pbnRlcmZhY2VzL3ZpZXcnO1xuXG5pbXBvcnQge0lTX0hZRFJBVElPTl9GRUFUVVJFX0VOQUJMRUR9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7ZGVjb21wcmVzc05naEluZm99IGZyb20gJy4vY29tcHJlc3Npb24nO1xuaW1wb3J0IHtOZ2hEb20sIE5PREVTfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgY29uc3QgTkdIX0FUVFJfTkFNRSA9ICduZ2gnO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1RFWFRfTk9ERV9DT01NRU5UID0gJ25nZXRuJztcbmV4cG9ydCBjb25zdCBURVhUX05PREVfU0VQQVJBVE9SX0NPTU1FTlQgPSAnbmd0bnMnO1xuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHRoYXQgcmVhZHMgYG5naGAgYXR0cmlidXRlIGZyb21cbiAqIGEgZ2l2ZW4gUk5vZGUuIFJldHVybnMgYG51bGxgIGJ5IGRlZmF1bHQsIHdoZW4gaHlkcmF0aW9uIGlzIG5vdCBlbmFibGVkLlxuICogQHBhcmFtIHJOb2RlXG4gKi9cbmxldCBfcmV0cmlldmVOZ2hJbmZvSW1wbDogdHlwZW9mIHJldHJpZXZlTmdoSW5mb0ltcGwgPSAock5vZGU6IFJFbGVtZW50KSA9PiBudWxsO1xuXG5mdW5jdGlvbiByZXRyaWV2ZU5naEluZm9JbXBsKHJOb2RlOiBSRWxlbWVudCk6IE5naERvbXxudWxsIHtcbiAgbGV0IG5naEluZm86IE5naERvbXxudWxsID0gbnVsbDtcbiAgY29uc3QgbmdoQXR0clZhbHVlID0gKHJOb2RlIGFzIEhUTUxFbGVtZW50KS5nZXRBdHRyaWJ1dGUoTkdIX0FUVFJfTkFNRSk7XG4gIGlmIChuZ2hBdHRyVmFsdWUgIT0gbnVsbCkge1xuICAgIG5naEluZm8gPSBuZ2hBdHRyVmFsdWUgIT09ICcnID8gZGVjb21wcmVzc05naEluZm8obmdoQXR0clZhbHVlKSA6IHt9O1xuICAgIG5naEluZm8uZmlyc3RDaGlsZCA9IChyTm9kZSBhcyBIVE1MRWxlbWVudCkuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudDtcbiAgICByTm9kZS5yZW1vdmVBdHRyaWJ1dGUoTkdIX0FUVFJfTkFNRSk7XG4gICAgLy8gTm90ZTogZG9uJ3QgY2hlY2sgd2hldGhlciB0aGlzIG5vZGUgd2FzIGNsYWltZWQgZm9yIGh5ZHJhdGlvbixcbiAgICAvLyBiZWNhdXNlIHRoaXMgbm9kZSBtaWdodCd2ZSBiZWVuIHByZXZpb3VzbHkgY2xhaW1lZCB3aGlsZSBwcm9jZXNzaW5nXG4gICAgLy8gdGVtcGxhdGUgaW5zdHJ1Y3Rpb25zLlxuICAgIG5nRGV2TW9kZSAmJiBtYXJrUk5vZGVBc0NsYWltZWRGb3JIeWRyYXRpb24ock5vZGUsIC8qIGNoZWNrSWZBbHJlYWR5Q2xhaW1lZCAqLyBmYWxzZSk7XG4gICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5oeWRyYXRlZENvbXBvbmVudHMrKztcbiAgfVxuICByZXR1cm4gbmdoSW5mbztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVJldHJpZXZlTmdoSW5mb0ltcGwoKSB7XG4gIF9yZXRyaWV2ZU5naEluZm9JbXBsID0gcmV0cmlldmVOZ2hJbmZvSW1wbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlTmdoSW5mbyhyTm9kZTogUkVsZW1lbnQpOiBOZ2hEb218bnVsbCB7XG4gIHJldHVybiBfcmV0cmlldmVOZ2hJbmZvSW1wbChyTm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRMVmlldyh2aWV3UmVmOiBWaWV3UmVmKSB7XG4gIGxldCBsVmlldyA9ICh2aWV3UmVmIGFzIGFueSkuX2xWaWV3O1xuICBpZiAoaXNSb290VmlldyhsVmlldykpIHtcbiAgICBsVmlldyA9IGxWaWV3W0hFQURFUl9PRkZTRVRdO1xuICB9XG4gIHJldHVybiBsVmlldztcbn1cblxuXG50eXBlIENsYWltZWROb2RlID0ge1xuICBfX2NsYWltZWQ/OiBib29sZWFuXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1RleHROb2RlTWFya2Vyc0JlZm9yZUh5ZHJhdGlvbihub2RlOiBIVE1MRWxlbWVudCkge1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCBjb21tZW50SXRlcmF0b3IgPSBkb2MuY3JlYXRlTm9kZUl0ZXJhdG9yKG5vZGUsIE5vZGVGaWx0ZXIuU0hPV19DT01NRU5ULCB7XG4gICAgYWNjZXB0Tm9kZShub2RlKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnN0IGlzVGV4dE5vZGVNYXJrZXIgPVxuICAgICAgICAgIGNvbnRlbnQgPT09IEVNUFRZX1RFWFRfTk9ERV9DT01NRU5UIHx8IGNvbnRlbnQgPT09IFRFWFRfTk9ERV9TRVBBUkFUT1JfQ09NTUVOVDtcbiAgICAgIHJldHVybiBpc1RleHROb2RlTWFya2VyID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgIH1cbiAgfSk7XG4gIGxldCBjdXJyZW50Tm9kZTogQ29tbWVudDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlID0gY29tbWVudEl0ZXJhdG9yLm5leHROb2RlKCkgYXMgQ29tbWVudCkge1xuICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9PT0gRU1QVFlfVEVYVF9OT0RFX0NPTU1FTlQpIHtcbiAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2VXaXRoKGRvYy5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2F0ZUhvc3RFbGVtZW50SW1wbChcbiAgICByZW5kZXJlcjogUmVuZGVyZXIsIGVsZW1lbnRPclNlbGVjdG9yOiBSRWxlbWVudHxzdHJpbmcsIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLFxuICAgIGluamVjdG9yOiBJbmplY3Rvcik6IFJFbGVtZW50IHtcbiAgY29uc3QgaXNIeWRyYXRpb25FbmFibGVkID0gaW5qZWN0b3IuZ2V0KElTX0hZRFJBVElPTl9GRUFUVVJFX0VOQUJMRUQsIGZhbHNlKTtcblxuICAvLyBGSVhNRTogdGhpcyBpcyBhIGZpeCB0byB0aGUgcHJvYmxlbSB0aGF0IGhhcHBlbnMgaW4gdGVzdHMgOihcbiAgLy8gV2UgbG9hZCBleHRyYSBjb2RlIGZyb20gYHByb3ZpZGVIeWRyYXRpb25TdXBwb3J0YCBmbiwgYnV0IGl0IGlzIHJldGFpbmVkXG4gIC8vIHRocm91Z2hvdXQgdGhlIGV4ZWN1dGlvbiBvZiBhbGwgdGVzdHMsIHRodXMgYWxzbyBtYWtpbmcgaXQgaW50b1xuICAvLyBTU1IgY29kZSBwYXRoLiBXZSBzaG91bGQgaW52ZXN0aWdhdGUgaG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaGVyZS5cbiAgY29uc3QgaXNCcm93c2VyID0gaW5qZWN0b3IuZ2V0KFBMQVRGT1JNX0lEKSA9PT0gJ2Jyb3dzZXInO1xuXG4gIGNvbnN0IHByZXNlcnZlQ29udGVudCA9XG4gICAgICAoaXNCcm93c2VyICYmIGlzSHlkcmF0aW9uRW5hYmxlZCkgfHwgZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uU2hhZG93RG9tO1xuICBjb25zdCByb290RWxlbWVudCA9IHJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KGVsZW1lbnRPclNlbGVjdG9yLCBwcmVzZXJ2ZUNvbnRlbnQpO1xuICBpZiAoaXNIeWRyYXRpb25FbmFibGVkKSB7XG4gICAgcHJvY2Vzc1RleHROb2RlTWFya2Vyc0JlZm9yZUh5ZHJhdGlvbihyb290RWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJvb3RFbGVtZW50O1xufTtcblxuLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgV2Vha01hcCBpbnN0ZWFkLlxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtSTm9kZUFzQ2xhaW1lZEZvckh5ZHJhdGlvbihub2RlOiBSTm9kZSwgY2hlY2tJZkFscmVhZHlDbGFpbWVkID0gdHJ1ZSkge1xuICBpZiAoIW5nRGV2TW9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyBgY2xhaW1Ob2RlYCBpbiBwcm9kIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBhbmQgbGlrZWx5IGEgbWlzdGFrZS4nKTtcbiAgfVxuICBpZiAoY2hlY2tJZkFscmVhZHlDbGFpbWVkICYmIGlzUk5vZGVDbGFpbWVkRm9ySHlkcmF0aW9uKG5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gY2xhaW0gYSBub2RlLCB3aGljaCB3YXMgY2xhaW1lZCBhbHJlYWR5LicpO1xuICB9XG4gIChub2RlIGFzIENsYWltZWROb2RlKS5fX2NsYWltZWQgPSB0cnVlO1xuICBuZ0Rldk1vZGUuaHlkcmF0ZWROb2RlcysrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSTm9kZUNsYWltZWRGb3JIeWRyYXRpb24obm9kZTogUk5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKG5vZGUgYXMgQ2xhaW1lZE5vZGUpLl9fY2xhaW1lZDtcbn1cblxuLyoqXG4gKiBTcGVjaWFsIG1hcmtlciB0aGF0IGluZGljYXRlcyB0aGF0IHRoaXMgbm9kZSB3YXMgZHJvcHBlZFxuICogZHVyaW5nIGNvbnRlbnQgcHJvamVjdGlvbi4gV2UgbmVlZCB0byByZS1jcmVhdGUgdGhpcyBub2RlXG4gKiBmcm9tIHNjcmF0Y2ggZHVyaW5nIGh5ZHJhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IERST1BQRURfUFJPSkVDVEVEX05PREUgPSAnZCc7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBub2RlIGlzIGFubm90YXRlZCBhcyBcImRpc2Nvbm5lY3RlZFwiLCBpLmUuIG5vdCBwcmVzZW50XG4gKiBpbiBsaXZlIERPTSBhdCBzZXJpYWxpemF0aW9uIHRpbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVEaXNjb25uZWN0ZWQoaHlkcmF0aW9uSW5mbzogTmdoRG9tLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBoeWRyYXRpb25JbmZvW05PREVTXT8uW2luZGV4XSA9PT0gRFJPUFBFRF9QUk9KRUNURURfTk9ERTtcbn1cbiJdfQ==