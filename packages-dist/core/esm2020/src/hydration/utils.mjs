/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { PLATFORM_ID, TRANSFER_STATE } from '../application_tokens';
import { ViewEncapsulation } from '../metadata/view';
import { getDocument } from '../render3/interfaces/document';
import { isRootView } from '../render3/interfaces/type_checks';
import { HEADER_OFFSET } from '../render3/interfaces/view';
import { NGH_DATA_KEY } from './annotate';
import { IS_HYDRATION_FEATURE_ENABLED } from './api';
import { NODES } from './interfaces';
export const NGH_ATTR_NAME = 'ngh';
export const EMPTY_TEXT_NODE_COMMENT = 'ngetn';
export const TEXT_NODE_SEPARATOR_COMMENT = 'ngtns';
/**
 * Reference to a function that reads `ngh` attribute from
 * a given RNode. Returns `null` by default, when hydration is not enabled.
 * @param rNode
 */
let _retrieveNghInfoImpl = (rNode, injector) => null;
function retrieveNghInfoImpl(rNode, injector) {
    const nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
    const transferState = injector.get(TRANSFER_STATE, null, { optional: true });
    if (transferState !== null) {
        const nghData = transferState.get(NGH_DATA_KEY, []) ?? [];
        if (nghAttrValue != null) {
            const nghDomInstance = {
                data: nghAttrValue !== '' ? nghData[Number(nghAttrValue)] : {},
                firstChild: rNode.firstChild,
            };
            rNode.removeAttribute(NGH_ATTR_NAME);
            // Note: don't check whether this node was claimed for hydration,
            // because this node might've been previously claimed while processing
            // template instructions.
            ngDevMode && markRNodeAsClaimedForHydration(rNode, /* checkIfAlreadyClaimed */ false);
            ngDevMode && ngDevMode.hydratedComponents++;
            return nghDomInstance;
        }
    }
    return null;
}
export function enableRetrieveNghInfoImpl() {
    _retrieveNghInfoImpl = retrieveNghInfoImpl;
}
export function retrieveNghInfo(rNode, injector) {
    return _retrieveNghInfoImpl(rNode, injector);
}
export function getComponentLView(viewRef) {
    let lView = viewRef._lView;
    if (isRootView(lView)) {
        lView = lView[HEADER_OFFSET];
    }
    return lView;
}
export function processTextNodeMarkersBeforeHydration(node) {
    const doc = getDocument();
    const commentIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
        acceptNode(node) {
            const content = node.textContent;
            const isTextNodeMarker = content === EMPTY_TEXT_NODE_COMMENT || content === TEXT_NODE_SEPARATOR_COMMENT;
            return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
    });
    let currentNode;
    while (currentNode = commentIterator.nextNode()) {
        if (currentNode.textContent === EMPTY_TEXT_NODE_COMMENT) {
            currentNode.replaceWith(doc.createTextNode(''));
        }
        else {
            currentNode.remove();
        }
    }
}
export function locateHostElementImpl(renderer, elementOrSelector, encapsulation, injector) {
    const isHydrationEnabled = injector.get(IS_HYDRATION_FEATURE_ENABLED, false);
    // FIXME: this is a fix to the problem that happens in tests :(
    // We load extra code from `provideHydrationSupport` fn, but it is retained
    // throughout the execution of all tests, thus also making it into
    // SSR code path. We should investigate how to avoid this check here.
    const isBrowser = injector.get(PLATFORM_ID) === 'browser';
    const preserveContent = (isBrowser && isHydrationEnabled) || encapsulation === ViewEncapsulation.ShadowDom;
    const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
    if (isHydrationEnabled) {
        processTextNodeMarkersBeforeHydration(rootElement);
    }
    return rootElement;
}
;
// TODO: consider using WeakMap instead.
export function markRNodeAsClaimedForHydration(node, checkIfAlreadyClaimed = true) {
    if (!ngDevMode) {
        throw new Error('Calling `claimNode` in prod mode is not supported and likely a mistake.');
    }
    if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
        throw new Error('Trying to claim a node, which was claimed already.');
    }
    node.__claimed = true;
    ngDevMode.hydratedNodes++;
}
export function isRNodeClaimedForHydration(node) {
    return !!node.__claimed;
}
/**
 * Special marker that indicates that this node was dropped
 * during content projection. We need to re-create this node
 * from scratch during hydration.
 */
export const DROPPED_PROJECTED_NODE = 'd';
/**
 * Checks whether a node is annotated as "disconnected", i.e. not present
 * in live DOM at serialization time.
 */
export function isNodeDisconnected(hydrationInfo, index) {
    return hydrationInfo.data[NODES]?.[index] === DROPPED_PROJECTED_NODE;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oeWRyYXRpb24vdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLFdBQVcsRUFBRSxjQUFjLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdsRSxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZ0NBQWdDLENBQUM7QUFHM0QsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG1DQUFtQyxDQUFDO0FBQzdELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUV6RCxPQUFPLEVBQUMsWUFBWSxFQUFnQixNQUFNLFlBQVksQ0FBQztBQUN2RCxPQUFPLEVBQUMsNEJBQTRCLEVBQUMsTUFBTSxPQUFPLENBQUM7QUFDbkQsT0FBTyxFQUF5QixLQUFLLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFM0QsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQztBQUNuQyxNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxPQUFPLENBQUM7QUFDL0MsTUFBTSxDQUFDLE1BQU0sMkJBQTJCLEdBQUcsT0FBTyxDQUFDO0FBRW5EOzs7O0dBSUc7QUFDSCxJQUFJLG9CQUFvQixHQUErQixDQUFDLEtBQWUsRUFBRSxRQUFrQixFQUFFLEVBQUUsQ0FDM0YsSUFBSSxDQUFDO0FBRVQsU0FBUyxtQkFBbUIsQ0FBQyxLQUFlLEVBQUUsUUFBa0I7SUFDOUQsTUFBTSxZQUFZLEdBQUksS0FBcUIsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDeEUsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsSUFBSSxFQUFFLEVBQUMsUUFBUSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7SUFDM0UsSUFBSSxhQUFhLEtBQUssSUFBSSxFQUFFO1FBQzFCLE1BQU0sT0FBTyxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUMxRCxJQUFJLFlBQVksSUFBSSxJQUFJLEVBQUU7WUFDeEIsTUFBTSxjQUFjLEdBQW1CO2dCQUNyQyxJQUFJLEVBQUUsWUFBWSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUM5RCxVQUFVLEVBQUcsS0FBcUIsQ0FBQyxVQUF5QjthQUM3RCxDQUFDO1lBQ0YsS0FBSyxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNyQyxpRUFBaUU7WUFDakUsc0VBQXNFO1lBQ3RFLHlCQUF5QjtZQUN6QixTQUFTLElBQUksOEJBQThCLENBQUMsS0FBSyxFQUFFLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RGLFNBQVMsSUFBSSxTQUFTLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUU1QyxPQUFPLGNBQWMsQ0FBQztTQUN2QjtLQUNGO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQsTUFBTSxVQUFVLHlCQUF5QjtJQUN2QyxvQkFBb0IsR0FBRyxtQkFBbUIsQ0FBQztBQUM3QyxDQUFDO0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FBQyxLQUFlLEVBQUUsUUFBa0I7SUFDakUsT0FBTyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxPQUFnQjtJQUNoRCxJQUFJLEtBQUssR0FBSSxPQUFlLENBQUMsTUFBTSxDQUFDO0lBQ3BDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDOUI7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFPRCxNQUFNLFVBQVUscUNBQXFDLENBQUMsSUFBaUI7SUFDckUsTUFBTSxHQUFHLEdBQUcsV0FBVyxFQUFFLENBQUM7SUFDMUIsTUFBTSxlQUFlLEdBQUcsR0FBRyxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsWUFBWSxFQUFFO1FBQzVFLFVBQVUsQ0FBQyxJQUFJO1lBQ2IsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUNqQyxNQUFNLGdCQUFnQixHQUNsQixPQUFPLEtBQUssdUJBQXVCLElBQUksT0FBTyxLQUFLLDJCQUEyQixDQUFDO1lBQ25GLE9BQU8sZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7UUFDaEYsQ0FBQztLQUNGLENBQUMsQ0FBQztJQUNILElBQUksV0FBb0IsQ0FBQztJQUN6QixPQUFPLFdBQVcsR0FBRyxlQUFlLENBQUMsUUFBUSxFQUFhLEVBQUU7UUFDMUQsSUFBSSxXQUFXLENBQUMsV0FBVyxLQUFLLHVCQUF1QixFQUFFO1lBQ3ZELFdBQVcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2pEO2FBQU07WUFDTCxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDdEI7S0FDRjtBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUscUJBQXFCLENBQ2pDLFFBQWtCLEVBQUUsaUJBQWtDLEVBQUUsYUFBZ0MsRUFDeEYsUUFBa0I7SUFDcEIsTUFBTSxrQkFBa0IsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLDRCQUE0QixFQUFFLEtBQUssQ0FBQyxDQUFDO0lBRTdFLCtEQUErRDtJQUMvRCwyRUFBMkU7SUFDM0Usa0VBQWtFO0lBQ2xFLHFFQUFxRTtJQUNyRSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLFNBQVMsQ0FBQztJQUUxRCxNQUFNLGVBQWUsR0FDakIsQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUMsSUFBSSxhQUFhLEtBQUssaUJBQWlCLENBQUMsU0FBUyxDQUFDO0lBQ3ZGLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUNuRixJQUFJLGtCQUFrQixFQUFFO1FBQ3RCLHFDQUFxQyxDQUFDLFdBQTBCLENBQUMsQ0FBQztLQUNuRTtJQUNELE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFBQSxDQUFDO0FBRUYsd0NBQXdDO0FBQ3hDLE1BQU0sVUFBVSw4QkFBOEIsQ0FBQyxJQUFXLEVBQUUscUJBQXFCLEdBQUcsSUFBSTtJQUN0RixJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDO0tBQzVGO0lBQ0QsSUFBSSxxQkFBcUIsSUFBSSwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUM3RCxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDdkU7SUFDQSxJQUFvQixDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFDdkMsU0FBUyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQzVCLENBQUM7QUFFRCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsSUFBVztJQUNwRCxPQUFPLENBQUMsQ0FBRSxJQUFvQixDQUFDLFNBQVMsQ0FBQztBQUMzQyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLEdBQUcsQ0FBQztBQUUxQzs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsYUFBNkIsRUFBRSxLQUFhO0lBQzdFLE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLHNCQUFzQixDQUFDO0FBQ3ZFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtQTEFURk9STV9JRCwgVFJBTlNGRVJfU1RBVEV9IGZyb20gJy4uL2FwcGxpY2F0aW9uX3Rva2Vucyc7XG5pbXBvcnQge0luamVjdG9yfSBmcm9tICcuLi9kaS9pbmplY3Rvcic7XG5pbXBvcnQge1ZpZXdSZWZ9IGZyb20gJy4uL2xpbmtlcic7XG5pbXBvcnQge1ZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICcuLi9tZXRhZGF0YS92aWV3JztcbmltcG9ydCB7Z2V0RG9jdW1lbnR9IGZyb20gJy4uL3JlbmRlcjMvaW50ZXJmYWNlcy9kb2N1bWVudCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvcmVuZGVyZXInO1xuaW1wb3J0IHtSRWxlbWVudCwgUk5vZGV9IGZyb20gJy4uL3JlbmRlcjMvaW50ZXJmYWNlcy9yZW5kZXJlcl9kb20nO1xuaW1wb3J0IHtpc1Jvb3RWaWV3fSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvdHlwZV9jaGVja3MnO1xuaW1wb3J0IHtIRUFERVJfT0ZGU0VUfSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvdmlldyc7XG5cbmltcG9ydCB7TkdIX0RBVEFfS0VZLCBUcmFuc2ZlclN0YXRlfSBmcm9tICcuL2Fubm90YXRlJztcbmltcG9ydCB7SVNfSFlEUkFUSU9OX0ZFQVRVUkVfRU5BQkxFRH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHtOZ2hEb20sIE5naERvbUluc3RhbmNlLCBOT0RFU30gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGNvbnN0IE5HSF9BVFRSX05BTUUgPSAnbmdoJztcbmV4cG9ydCBjb25zdCBFTVBUWV9URVhUX05PREVfQ09NTUVOVCA9ICduZ2V0bic7XG5leHBvcnQgY29uc3QgVEVYVF9OT0RFX1NFUEFSQVRPUl9DT01NRU5UID0gJ25ndG5zJztcblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiB0aGF0IHJlYWRzIGBuZ2hgIGF0dHJpYnV0ZSBmcm9tXG4gKiBhIGdpdmVuIFJOb2RlLiBSZXR1cm5zIGBudWxsYCBieSBkZWZhdWx0LCB3aGVuIGh5ZHJhdGlvbiBpcyBub3QgZW5hYmxlZC5cbiAqIEBwYXJhbSByTm9kZVxuICovXG5sZXQgX3JldHJpZXZlTmdoSW5mb0ltcGw6IHR5cGVvZiByZXRyaWV2ZU5naEluZm9JbXBsID0gKHJOb2RlOiBSRWxlbWVudCwgaW5qZWN0b3I6IEluamVjdG9yKSA9PlxuICAgIG51bGw7XG5cbmZ1bmN0aW9uIHJldHJpZXZlTmdoSW5mb0ltcGwock5vZGU6IFJFbGVtZW50LCBpbmplY3RvcjogSW5qZWN0b3IpOiBOZ2hEb21JbnN0YW5jZXxudWxsIHtcbiAgY29uc3QgbmdoQXR0clZhbHVlID0gKHJOb2RlIGFzIEhUTUxFbGVtZW50KS5nZXRBdHRyaWJ1dGUoTkdIX0FUVFJfTkFNRSk7XG4gIGNvbnN0IHRyYW5zZmVyU3RhdGUgPSBpbmplY3Rvci5nZXQoVFJBTlNGRVJfU1RBVEUsIG51bGwsIHtvcHRpb25hbDogdHJ1ZX0pO1xuICBpZiAodHJhbnNmZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5naERhdGEgPSB0cmFuc2ZlclN0YXRlLmdldChOR0hfREFUQV9LRVksIFtdKSA/PyBbXTtcbiAgICBpZiAobmdoQXR0clZhbHVlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5naERvbUluc3RhbmNlOiBOZ2hEb21JbnN0YW5jZSA9IHtcbiAgICAgICAgZGF0YTogbmdoQXR0clZhbHVlICE9PSAnJyA/IG5naERhdGFbTnVtYmVyKG5naEF0dHJWYWx1ZSldIDoge30sXG4gICAgICAgIGZpcnN0Q2hpbGQ6IChyTm9kZSBhcyBIVE1MRWxlbWVudCkuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudCxcbiAgICAgIH07XG4gICAgICByTm9kZS5yZW1vdmVBdHRyaWJ1dGUoTkdIX0FUVFJfTkFNRSk7XG4gICAgICAvLyBOb3RlOiBkb24ndCBjaGVjayB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgY2xhaW1lZCBmb3IgaHlkcmF0aW9uLFxuICAgICAgLy8gYmVjYXVzZSB0aGlzIG5vZGUgbWlnaHQndmUgYmVlbiBwcmV2aW91c2x5IGNsYWltZWQgd2hpbGUgcHJvY2Vzc2luZ1xuICAgICAgLy8gdGVtcGxhdGUgaW5zdHJ1Y3Rpb25zLlxuICAgICAgbmdEZXZNb2RlICYmIG1hcmtSTm9kZUFzQ2xhaW1lZEZvckh5ZHJhdGlvbihyTm9kZSwgLyogY2hlY2tJZkFscmVhZHlDbGFpbWVkICovIGZhbHNlKTtcbiAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUuaHlkcmF0ZWRDb21wb25lbnRzKys7XG5cbiAgICAgIHJldHVybiBuZ2hEb21JbnN0YW5jZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVSZXRyaWV2ZU5naEluZm9JbXBsKCkge1xuICBfcmV0cmlldmVOZ2hJbmZvSW1wbCA9IHJldHJpZXZlTmdoSW5mb0ltcGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXRyaWV2ZU5naEluZm8ock5vZGU6IFJFbGVtZW50LCBpbmplY3RvcjogSW5qZWN0b3IpOiBOZ2hEb21JbnN0YW5jZXxudWxsIHtcbiAgcmV0dXJuIF9yZXRyaWV2ZU5naEluZm9JbXBsKHJOb2RlLCBpbmplY3Rvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRMVmlldyh2aWV3UmVmOiBWaWV3UmVmKSB7XG4gIGxldCBsVmlldyA9ICh2aWV3UmVmIGFzIGFueSkuX2xWaWV3O1xuICBpZiAoaXNSb290VmlldyhsVmlldykpIHtcbiAgICBsVmlldyA9IGxWaWV3W0hFQURFUl9PRkZTRVRdO1xuICB9XG4gIHJldHVybiBsVmlldztcbn1cblxuXG50eXBlIENsYWltZWROb2RlID0ge1xuICBfX2NsYWltZWQ/OiBib29sZWFuXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1RleHROb2RlTWFya2Vyc0JlZm9yZUh5ZHJhdGlvbihub2RlOiBIVE1MRWxlbWVudCkge1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCBjb21tZW50SXRlcmF0b3IgPSBkb2MuY3JlYXRlTm9kZUl0ZXJhdG9yKG5vZGUsIE5vZGVGaWx0ZXIuU0hPV19DT01NRU5ULCB7XG4gICAgYWNjZXB0Tm9kZShub2RlKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnN0IGlzVGV4dE5vZGVNYXJrZXIgPVxuICAgICAgICAgIGNvbnRlbnQgPT09IEVNUFRZX1RFWFRfTk9ERV9DT01NRU5UIHx8IGNvbnRlbnQgPT09IFRFWFRfTk9ERV9TRVBBUkFUT1JfQ09NTUVOVDtcbiAgICAgIHJldHVybiBpc1RleHROb2RlTWFya2VyID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgIH1cbiAgfSk7XG4gIGxldCBjdXJyZW50Tm9kZTogQ29tbWVudDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlID0gY29tbWVudEl0ZXJhdG9yLm5leHROb2RlKCkgYXMgQ29tbWVudCkge1xuICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9PT0gRU1QVFlfVEVYVF9OT0RFX0NPTU1FTlQpIHtcbiAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2VXaXRoKGRvYy5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2F0ZUhvc3RFbGVtZW50SW1wbChcbiAgICByZW5kZXJlcjogUmVuZGVyZXIsIGVsZW1lbnRPclNlbGVjdG9yOiBSRWxlbWVudHxzdHJpbmcsIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLFxuICAgIGluamVjdG9yOiBJbmplY3Rvcik6IFJFbGVtZW50IHtcbiAgY29uc3QgaXNIeWRyYXRpb25FbmFibGVkID0gaW5qZWN0b3IuZ2V0KElTX0hZRFJBVElPTl9GRUFUVVJFX0VOQUJMRUQsIGZhbHNlKTtcblxuICAvLyBGSVhNRTogdGhpcyBpcyBhIGZpeCB0byB0aGUgcHJvYmxlbSB0aGF0IGhhcHBlbnMgaW4gdGVzdHMgOihcbiAgLy8gV2UgbG9hZCBleHRyYSBjb2RlIGZyb20gYHByb3ZpZGVIeWRyYXRpb25TdXBwb3J0YCBmbiwgYnV0IGl0IGlzIHJldGFpbmVkXG4gIC8vIHRocm91Z2hvdXQgdGhlIGV4ZWN1dGlvbiBvZiBhbGwgdGVzdHMsIHRodXMgYWxzbyBtYWtpbmcgaXQgaW50b1xuICAvLyBTU1IgY29kZSBwYXRoLiBXZSBzaG91bGQgaW52ZXN0aWdhdGUgaG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaGVyZS5cbiAgY29uc3QgaXNCcm93c2VyID0gaW5qZWN0b3IuZ2V0KFBMQVRGT1JNX0lEKSA9PT0gJ2Jyb3dzZXInO1xuXG4gIGNvbnN0IHByZXNlcnZlQ29udGVudCA9XG4gICAgICAoaXNCcm93c2VyICYmIGlzSHlkcmF0aW9uRW5hYmxlZCkgfHwgZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uU2hhZG93RG9tO1xuICBjb25zdCByb290RWxlbWVudCA9IHJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KGVsZW1lbnRPclNlbGVjdG9yLCBwcmVzZXJ2ZUNvbnRlbnQpO1xuICBpZiAoaXNIeWRyYXRpb25FbmFibGVkKSB7XG4gICAgcHJvY2Vzc1RleHROb2RlTWFya2Vyc0JlZm9yZUh5ZHJhdGlvbihyb290RWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJvb3RFbGVtZW50O1xufTtcblxuLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgV2Vha01hcCBpbnN0ZWFkLlxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtSTm9kZUFzQ2xhaW1lZEZvckh5ZHJhdGlvbihub2RlOiBSTm9kZSwgY2hlY2tJZkFscmVhZHlDbGFpbWVkID0gdHJ1ZSkge1xuICBpZiAoIW5nRGV2TW9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyBgY2xhaW1Ob2RlYCBpbiBwcm9kIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBhbmQgbGlrZWx5IGEgbWlzdGFrZS4nKTtcbiAgfVxuICBpZiAoY2hlY2tJZkFscmVhZHlDbGFpbWVkICYmIGlzUk5vZGVDbGFpbWVkRm9ySHlkcmF0aW9uKG5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gY2xhaW0gYSBub2RlLCB3aGljaCB3YXMgY2xhaW1lZCBhbHJlYWR5LicpO1xuICB9XG4gIChub2RlIGFzIENsYWltZWROb2RlKS5fX2NsYWltZWQgPSB0cnVlO1xuICBuZ0Rldk1vZGUuaHlkcmF0ZWROb2RlcysrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSTm9kZUNsYWltZWRGb3JIeWRyYXRpb24obm9kZTogUk5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKG5vZGUgYXMgQ2xhaW1lZE5vZGUpLl9fY2xhaW1lZDtcbn1cblxuLyoqXG4gKiBTcGVjaWFsIG1hcmtlciB0aGF0IGluZGljYXRlcyB0aGF0IHRoaXMgbm9kZSB3YXMgZHJvcHBlZFxuICogZHVyaW5nIGNvbnRlbnQgcHJvamVjdGlvbi4gV2UgbmVlZCB0byByZS1jcmVhdGUgdGhpcyBub2RlXG4gKiBmcm9tIHNjcmF0Y2ggZHVyaW5nIGh5ZHJhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IERST1BQRURfUFJPSkVDVEVEX05PREUgPSAnZCc7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBub2RlIGlzIGFubm90YXRlZCBhcyBcImRpc2Nvbm5lY3RlZFwiLCBpLmUuIG5vdCBwcmVzZW50XG4gKiBpbiBsaXZlIERPTSBhdCBzZXJpYWxpemF0aW9uIHRpbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVEaXNjb25uZWN0ZWQoaHlkcmF0aW9uSW5mbzogTmdoRG9tSW5zdGFuY2UsIGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGh5ZHJhdGlvbkluZm8uZGF0YVtOT0RFU10/LltpbmRleF0gPT09IERST1BQRURfUFJPSkVDVEVEX05PREU7XG59XG4iXX0=