/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertDefined, assertEqual, assertNumber, throwError } from '../util/assert';
import { getComponentDef, getNgModuleDef } from './definition';
import { isLContainer, isLView } from './interfaces/type_checks';
import { DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, T_HOST, TVIEW } from './interfaces/view';
// [Assert functions do not constraint type when they are guarded by a truthy
// expression.](https://github.com/microsoft/TypeScript/issues/37295)
export function assertTNodeForLView(tNode, lView) {
    assertTNodeForTView(tNode, lView[TVIEW]);
}
export function assertTNodeForTView(tNode, tView) {
    assertTNode(tNode);
    tNode.hasOwnProperty('tView_') &&
        assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');
}
export function assertTNode(tNode) {
    assertDefined(tNode, 'TNode must be defined');
    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {
        throwError('Not of type TNode, got: ' + tNode);
    }
}
export function assertTIcu(tIcu) {
    assertDefined(tIcu, 'Expected TIcu to be defined');
    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {
        throwError('Object is not of TIcu type.');
    }
}
export function assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \'ɵcmp\' property.') {
    if (!getComponentDef(actual)) {
        throwError(msg);
    }
}
export function assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \'ɵmod\' property.') {
    if (!getNgModuleDef(actual)) {
        throwError(msg);
    }
}
export function assertCurrentTNodeIsParent(isParent) {
    assertEqual(isParent, true, 'currentTNode should be a parent');
}
export function assertHasParent(tNode) {
    assertDefined(tNode, 'currentTNode should exist!');
    assertDefined(tNode.parent, 'currentTNode should have a parent');
}
export function assertLContainer(value) {
    assertDefined(value, 'LContainer must be defined');
    assertEqual(isLContainer(value), true, 'Expecting LContainer');
}
export function assertLViewOrUndefined(value) {
    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
}
export function assertLView(value) {
    assertDefined(value, 'LView must be defined');
    assertEqual(isLView(value), true, 'Expecting LView');
}
export function assertFirstCreatePass(tView, errMessage) {
    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
}
export function assertFirstUpdatePass(tView, errMessage) {
    assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');
}
/**
 * This is a basic sanity check that an object is probably a directive def. DirectiveDef is
 * an interface, so we can't do a direct instanceof check.
 */
export function assertDirectiveDef(obj) {
    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {
        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
    }
}
export function assertIndexInDeclRange(lView, index) {
    const tView = lView[1];
    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
export function assertIndexInExpandoRange(lView, index) {
    const tView = lView[1];
    assertBetween(tView.expandoStartIndex, lView.length, index);
}
export function assertBetween(lower, upper, index) {
    if (!(lower <= index && index < upper)) {
        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
    }
}
export function assertProjectionSlots(lView, errMessage) {
    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');
    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage ||
        'Components with projection nodes (<ng-content>) must have projection slots defined.');
}
export function assertParentView(lView, errMessage) {
    assertDefined(lView, errMessage || 'Component views should always have a parent view (component\'s host view)');
}
/**
 * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a
 * NodeInjector data structure.
 *
 * @param lView `LView` which should be checked.
 * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.
 */
export function assertNodeInjector(lView, injectorIndex) {
    assertIndexInExpandoRange(lView, injectorIndex);
    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);
    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');
}
export function assertRComment(native, errMessage) {
    assertEqual(native.nodeType, Node.COMMENT_NODE, errMessage ?? 'Expected this element to be a comment node');
}
export function assertRElement(native, tagName, errMessage) {
    assertEqual(native.nodeType, Node.ELEMENT_NODE, errMessage ?? 'Expected this element to be an element node');
    assertEqual(native.tagName.toLowerCase(), tagName, errMessage ?? `Expected this element node to have the ${tagName} tag name`);
}
export function assertRText(native, errMessage) {
    assertEqual(native.nodeType, Node.TEXT_NODE, errMessage ?? 'Expected this element to be a text node');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9hc3NlcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRXBGLE9BQU8sRUFBQyxlQUFlLEVBQUUsY0FBYyxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBTzdELE9BQU8sRUFBQyxZQUFZLEVBQUUsT0FBTyxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDL0QsT0FBTyxFQUFDLDBCQUEwQixFQUFFLGFBQWEsRUFBUyxNQUFNLEVBQUUsS0FBSyxFQUFRLE1BQU0sbUJBQW1CLENBQUM7QUFFekcsNkVBQTZFO0FBQzdFLHFFQUFxRTtBQUdyRSxNQUFNLFVBQVUsbUJBQW1CLENBQUMsS0FBWSxFQUFFLEtBQVk7SUFDNUQsbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFFRCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsS0FBWSxFQUFFLEtBQVk7SUFDNUQsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25CLEtBQUssQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDO1FBQzFCLFdBQVcsQ0FDTixLQUFnQyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQy9DLDJDQUEyQyxDQUFDLENBQUM7QUFDdkQsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQUMsS0FBWTtJQUN0QyxhQUFhLENBQUMsS0FBSyxFQUFFLHVCQUF1QixDQUFDLENBQUM7SUFDOUMsSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLHNCQUFzQixDQUFDLENBQUMsRUFBRTtRQUN6RixVQUFVLENBQUMsMEJBQTBCLEdBQUcsS0FBSyxDQUFDLENBQUM7S0FDaEQ7QUFDSCxDQUFDO0FBR0QsTUFBTSxVQUFVLFVBQVUsQ0FBQyxJQUFVO0lBQ25DLGFBQWEsQ0FBQyxJQUFJLEVBQUUsNkJBQTZCLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxxQkFBcUIsS0FBSyxRQUFRLENBQUMsRUFBRTtRQUNyRCxVQUFVLENBQUMsNkJBQTZCLENBQUMsQ0FBQztLQUMzQztBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsbUJBQW1CLENBQy9CLE1BQVcsRUFDWCxNQUFjLDBFQUEwRTtJQUMxRixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQzVCLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqQjtBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsa0JBQWtCLENBQzlCLE1BQVcsRUFDWCxNQUFjLHlFQUF5RTtJQUN6RixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQzNCLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqQjtBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsUUFBaUI7SUFDMUQsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsaUNBQWlDLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FBQyxLQUFpQjtJQUMvQyxhQUFhLENBQUMsS0FBSyxFQUFFLDRCQUE0QixDQUFDLENBQUM7SUFDbkQsYUFBYSxDQUFDLEtBQU0sQ0FBQyxNQUFNLEVBQUUsbUNBQW1DLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLEtBQVU7SUFDekMsYUFBYSxDQUFDLEtBQUssRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO0lBQ25ELFdBQVcsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxFQUFFLHNCQUFzQixDQUFDLENBQUM7QUFDakUsQ0FBQztBQUVELE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxLQUFVO0lBQy9DLEtBQUssSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxzQ0FBc0MsQ0FBQyxDQUFDO0FBQ3JGLENBQUM7QUFFRCxNQUFNLFVBQVUsV0FBVyxDQUFDLEtBQVU7SUFDcEMsYUFBYSxDQUFDLEtBQUssRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQzlDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixDQUFDLENBQUM7QUFDdkQsQ0FBQztBQUVELE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxLQUFZLEVBQUUsVUFBbUI7SUFDckUsV0FBVyxDQUNQLEtBQUssQ0FBQyxlQUFlLEVBQUUsSUFBSSxFQUFFLFVBQVUsSUFBSSw2Q0FBNkMsQ0FBQyxDQUFDO0FBQ2hHLENBQUM7QUFFRCxNQUFNLFVBQVUscUJBQXFCLENBQUMsS0FBWSxFQUFFLFVBQW1CO0lBQ3JFLFdBQVcsQ0FDUCxLQUFLLENBQUMsZUFBZSxFQUFFLElBQUksRUFBRSxVQUFVLElBQUksNkNBQTZDLENBQUMsQ0FBQztBQUNoRyxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFJLEdBQVE7SUFDNUMsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxHQUFHLENBQUMsU0FBUyxJQUFJLFNBQVMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtRQUNwRixVQUFVLENBQ04sZ0dBQWdHLENBQUMsQ0FBQztLQUN2RztBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsS0FBWSxFQUFFLEtBQWE7SUFDaEUsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLGFBQWEsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFFRCxNQUFNLFVBQVUseUJBQXlCLENBQUMsS0FBWSxFQUFFLEtBQWE7SUFDbkUsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLGFBQWEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBRUQsTUFBTSxVQUFVLGFBQWEsQ0FBQyxLQUFhLEVBQUUsS0FBYSxFQUFFLEtBQWE7SUFDdkUsSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEVBQUU7UUFDdEMsVUFBVSxDQUFDLGlDQUFpQyxLQUFLLE9BQU8sS0FBSyxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDOUU7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLHFCQUFxQixDQUFDLEtBQVksRUFBRSxVQUFtQjtJQUNyRSxhQUFhLENBQUMsS0FBSyxDQUFDLDBCQUEwQixDQUFDLEVBQUUsK0JBQStCLENBQUMsQ0FBQztJQUNsRixhQUFhLENBQ1QsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUMsTUFBTSxDQUFFLENBQUMsVUFBVSxFQUNyRCxVQUFVO1FBQ04scUZBQXFGLENBQUMsQ0FBQztBQUNqRyxDQUFDO0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLEtBQWlCLEVBQUUsVUFBbUI7SUFDckUsYUFBYSxDQUNULEtBQUssRUFDTCxVQUFVLElBQUksMkVBQTJFLENBQUMsQ0FBQztBQUNqRyxDQUFDO0FBR0Q7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLEtBQVksRUFBRSxhQUFxQjtJQUNwRSx5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDaEQseUJBQXlCLENBQUMsS0FBSyxFQUFFLGFBQWEsb0NBQTRCLENBQUMsQ0FBQztJQUM1RSxZQUFZLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRSw4Q0FBOEMsQ0FBQyxDQUFDO0lBQ3ZGLFlBQVksQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFLDhDQUE4QyxDQUFDLENBQUM7SUFDdkYsWUFBWSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLEVBQUUsOENBQThDLENBQUMsQ0FBQztJQUN2RixZQUFZLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRSw4Q0FBOEMsQ0FBQyxDQUFDO0lBQ3ZGLFlBQVksQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFLDhDQUE4QyxDQUFDLENBQUM7SUFDdkYsWUFBWSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLEVBQUUsOENBQThDLENBQUMsQ0FBQztJQUN2RixZQUFZLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRSw4Q0FBOEMsQ0FBQyxDQUFDO0lBQ3ZGLFlBQVksQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFLDhDQUE4QyxDQUFDLENBQUM7SUFDdkYsWUFBWSxDQUNSLEtBQUssQ0FBQyxhQUFhLG9DQUE0QixDQUFDLEVBQ2hELCtDQUErQyxDQUFDLENBQUM7QUFDdkQsQ0FBQztBQUVELE1BQU0sVUFBVSxjQUFjLENBQUMsTUFBYSxFQUFFLFVBQW1CO0lBQy9ELFdBQVcsQ0FDTixNQUFzQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUNuRCxVQUFVLElBQUksNENBQTRDLENBQUMsQ0FBQztBQUNsRSxDQUFDO0FBRUQsTUFBTSxVQUFVLGNBQWMsQ0FBQyxNQUFhLEVBQUUsT0FBZSxFQUFFLFVBQW1CO0lBQ2hGLFdBQVcsQ0FDTixNQUFzQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUNuRCxVQUFVLElBQUksNkNBQTZDLENBQUMsQ0FBQztJQUNqRSxXQUFXLENBQ04sTUFBc0IsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUN0RCxVQUFVLElBQUksMENBQTBDLE9BQU8sV0FBVyxDQUFDLENBQUM7QUFDbEYsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQUMsTUFBYSxFQUFFLFVBQW1CO0lBQzVELFdBQVcsQ0FDTixNQUFzQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUNoRCxVQUFVLElBQUkseUNBQXlDLENBQUMsQ0FBQztBQUMvRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7YXNzZXJ0RGVmaW5lZCwgYXNzZXJ0RXF1YWwsIGFzc2VydE51bWJlciwgdGhyb3dFcnJvcn0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG5pbXBvcnQge2dldENvbXBvbmVudERlZiwgZ2V0TmdNb2R1bGVEZWZ9IGZyb20gJy4vZGVmaW5pdGlvbic7XG5pbXBvcnQge0xDb250YWluZXJ9IGZyb20gJy4vaW50ZXJmYWNlcy9jb250YWluZXInO1xuaW1wb3J0IHtEaXJlY3RpdmVEZWZ9IGZyb20gJy4vaW50ZXJmYWNlcy9kZWZpbml0aW9uJztcbmltcG9ydCB7VEljdX0gZnJvbSAnLi9pbnRlcmZhY2VzL2kxOG4nO1xuaW1wb3J0IHtOb2RlSW5qZWN0b3JPZmZzZXR9IGZyb20gJy4vaW50ZXJmYWNlcy9pbmplY3Rvcic7XG5pbXBvcnQge1ROb2RlfSBmcm9tICcuL2ludGVyZmFjZXMvbm9kZSc7XG5pbXBvcnQge1JDb21tZW50LCBSTm9kZX0gZnJvbSAnLi9pbnRlcmZhY2VzL3JlbmRlcmVyX2RvbSc7XG5pbXBvcnQge2lzTENvbnRhaW5lciwgaXNMVmlld30gZnJvbSAnLi9pbnRlcmZhY2VzL3R5cGVfY2hlY2tzJztcbmltcG9ydCB7REVDTEFSQVRJT05fQ09NUE9ORU5UX1ZJRVcsIEhFQURFUl9PRkZTRVQsIExWaWV3LCBUX0hPU1QsIFRWSUVXLCBUVmlld30gZnJvbSAnLi9pbnRlcmZhY2VzL3ZpZXcnO1xuXG4vLyBbQXNzZXJ0IGZ1bmN0aW9ucyBkbyBub3QgY29uc3RyYWludCB0eXBlIHdoZW4gdGhleSBhcmUgZ3VhcmRlZCBieSBhIHRydXRoeVxuLy8gZXhwcmVzc2lvbi5dKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcyOTUpXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFROb2RlRm9yTFZpZXcodE5vZGU6IFROb2RlLCBsVmlldzogTFZpZXcpIHtcbiAgYXNzZXJ0VE5vZGVGb3JUVmlldyh0Tm9kZSwgbFZpZXdbVFZJRVddKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFROb2RlRm9yVFZpZXcodE5vZGU6IFROb2RlLCB0VmlldzogVFZpZXcpIHtcbiAgYXNzZXJ0VE5vZGUodE5vZGUpO1xuICB0Tm9kZS5oYXNPd25Qcm9wZXJ0eSgndFZpZXdfJykgJiZcbiAgICAgIGFzc2VydEVxdWFsKFxuICAgICAgICAgICh0Tm9kZSBhcyBhbnkgYXMge3RWaWV3XzogVFZpZXd9KS50Vmlld18sIHRWaWV3LFxuICAgICAgICAgICdUaGlzIFROb2RlIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIFRWaWV3LicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VE5vZGUodE5vZGU6IFROb2RlKSB7XG4gIGFzc2VydERlZmluZWQodE5vZGUsICdUTm9kZSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgaWYgKCEodE5vZGUgJiYgdHlwZW9mIHROb2RlID09PSAnb2JqZWN0JyAmJiB0Tm9kZS5oYXNPd25Qcm9wZXJ0eSgnZGlyZWN0aXZlU3R5bGluZ0xhc3QnKSkpIHtcbiAgICB0aHJvd0Vycm9yKCdOb3Qgb2YgdHlwZSBUTm9kZSwgZ290OiAnICsgdE5vZGUpO1xuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFRJY3UodEljdTogVEljdSkge1xuICBhc3NlcnREZWZpbmVkKHRJY3UsICdFeHBlY3RlZCBUSWN1IHRvIGJlIGRlZmluZWQnKTtcbiAgaWYgKCEodHlwZW9mIHRJY3UuY3VycmVudENhc2VMVmlld0luZGV4ID09PSAnbnVtYmVyJykpIHtcbiAgICB0aHJvd0Vycm9yKCdPYmplY3QgaXMgbm90IG9mIFRJY3UgdHlwZS4nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50VHlwZShcbiAgICBhY3R1YWw6IGFueSxcbiAgICBtc2c6IHN0cmluZyA9ICdUeXBlIHBhc3NlZCBpbiBpcyBub3QgQ29tcG9uZW50VHlwZSwgaXQgZG9lcyBub3QgaGF2ZSBcXCfJtWNtcFxcJyBwcm9wZXJ0eS4nKSB7XG4gIGlmICghZ2V0Q29tcG9uZW50RGVmKGFjdHVhbCkpIHtcbiAgICB0aHJvd0Vycm9yKG1zZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5nTW9kdWxlVHlwZShcbiAgICBhY3R1YWw6IGFueSxcbiAgICBtc2c6IHN0cmluZyA9ICdUeXBlIHBhc3NlZCBpbiBpcyBub3QgTmdNb2R1bGVUeXBlLCBpdCBkb2VzIG5vdCBoYXZlIFxcJ8m1bW9kXFwnIHByb3BlcnR5LicpIHtcbiAgaWYgKCFnZXROZ01vZHVsZURlZihhY3R1YWwpKSB7XG4gICAgdGhyb3dFcnJvcihtc2cpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRDdXJyZW50VE5vZGVJc1BhcmVudChpc1BhcmVudDogYm9vbGVhbikge1xuICBhc3NlcnRFcXVhbChpc1BhcmVudCwgdHJ1ZSwgJ2N1cnJlbnRUTm9kZSBzaG91bGQgYmUgYSBwYXJlbnQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEhhc1BhcmVudCh0Tm9kZTogVE5vZGV8bnVsbCkge1xuICBhc3NlcnREZWZpbmVkKHROb2RlLCAnY3VycmVudFROb2RlIHNob3VsZCBleGlzdCEnKTtcbiAgYXNzZXJ0RGVmaW5lZCh0Tm9kZSEucGFyZW50LCAnY3VycmVudFROb2RlIHNob3VsZCBoYXZlIGEgcGFyZW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRMQ29udGFpbmVyKHZhbHVlOiBhbnkpOiBhc3NlcnRzIHZhbHVlIGlzIExDb250YWluZXIge1xuICBhc3NlcnREZWZpbmVkKHZhbHVlLCAnTENvbnRhaW5lciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgYXNzZXJ0RXF1YWwoaXNMQ29udGFpbmVyKHZhbHVlKSwgdHJ1ZSwgJ0V4cGVjdGluZyBMQ29udGFpbmVyJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRMVmlld09yVW5kZWZpbmVkKHZhbHVlOiBhbnkpOiBhc3NlcnRzIHZhbHVlIGlzIExWaWV3fG51bGx8dW5kZWZpbmVkIHtcbiAgdmFsdWUgJiYgYXNzZXJ0RXF1YWwoaXNMVmlldyh2YWx1ZSksIHRydWUsICdFeHBlY3RpbmcgTFZpZXcgb3IgdW5kZWZpbmVkIG9yIG51bGwnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydExWaWV3KHZhbHVlOiBhbnkpOiBhc3NlcnRzIHZhbHVlIGlzIExWaWV3IHtcbiAgYXNzZXJ0RGVmaW5lZCh2YWx1ZSwgJ0xWaWV3IG11c3QgYmUgZGVmaW5lZCcpO1xuICBhc3NlcnRFcXVhbChpc0xWaWV3KHZhbHVlKSwgdHJ1ZSwgJ0V4cGVjdGluZyBMVmlldycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Rmlyc3RDcmVhdGVQYXNzKHRWaWV3OiBUVmlldywgZXJyTWVzc2FnZT86IHN0cmluZykge1xuICBhc3NlcnRFcXVhbChcbiAgICAgIHRWaWV3LmZpcnN0Q3JlYXRlUGFzcywgdHJ1ZSwgZXJyTWVzc2FnZSB8fCAnU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIGZpcnN0IGNyZWF0ZSBwYXNzLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Rmlyc3RVcGRhdGVQYXNzKHRWaWV3OiBUVmlldywgZXJyTWVzc2FnZT86IHN0cmluZykge1xuICBhc3NlcnRFcXVhbChcbiAgICAgIHRWaWV3LmZpcnN0VXBkYXRlUGFzcywgdHJ1ZSwgZXJyTWVzc2FnZSB8fCAnU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIGZpcnN0IHVwZGF0ZSBwYXNzLicpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBiYXNpYyBzYW5pdHkgY2hlY2sgdGhhdCBhbiBvYmplY3QgaXMgcHJvYmFibHkgYSBkaXJlY3RpdmUgZGVmLiBEaXJlY3RpdmVEZWYgaXNcbiAqIGFuIGludGVyZmFjZSwgc28gd2UgY2FuJ3QgZG8gYSBkaXJlY3QgaW5zdGFuY2VvZiBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERpcmVjdGl2ZURlZjxUPihvYmo6IGFueSk6IGFzc2VydHMgb2JqIGlzIERpcmVjdGl2ZURlZjxUPiB7XG4gIGlmIChvYmoudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG9iai5zZWxlY3RvcnMgPT0gdW5kZWZpbmVkIHx8IG9iai5pbnB1dHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93RXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBhIERpcmVjdGl2ZURlZi9Db21wb25lbnREZWYgYW5kIHRoaXMgb2JqZWN0IGRvZXMgbm90IHNlZW0gdG8gaGF2ZSB0aGUgZXhwZWN0ZWQgc2hhcGUuYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEluZGV4SW5EZWNsUmFuZ2UobFZpZXc6IExWaWV3LCBpbmRleDogbnVtYmVyKSB7XG4gIGNvbnN0IHRWaWV3ID0gbFZpZXdbMV07XG4gIGFzc2VydEJldHdlZW4oSEVBREVSX09GRlNFVCwgdFZpZXcuYmluZGluZ1N0YXJ0SW5kZXgsIGluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEluZGV4SW5FeHBhbmRvUmFuZ2UobFZpZXc6IExWaWV3LCBpbmRleDogbnVtYmVyKSB7XG4gIGNvbnN0IHRWaWV3ID0gbFZpZXdbMV07XG4gIGFzc2VydEJldHdlZW4odFZpZXcuZXhwYW5kb1N0YXJ0SW5kZXgsIGxWaWV3Lmxlbmd0aCwgaW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QmV0d2Vlbihsb3dlcjogbnVtYmVyLCB1cHBlcjogbnVtYmVyLCBpbmRleDogbnVtYmVyKSB7XG4gIGlmICghKGxvd2VyIDw9IGluZGV4ICYmIGluZGV4IDwgdXBwZXIpKSB7XG4gICAgdGhyb3dFcnJvcihgSW5kZXggb3V0IG9mIHJhbmdlIChleHBlY3RpbmcgJHtsb3dlcn0gPD0gJHtpbmRleH0gPCAke3VwcGVyfSlgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJvamVjdGlvblNsb3RzKGxWaWV3OiBMVmlldywgZXJyTWVzc2FnZT86IHN0cmluZykge1xuICBhc3NlcnREZWZpbmVkKGxWaWV3W0RFQ0xBUkFUSU9OX0NPTVBPTkVOVF9WSUVXXSwgJ0NvbXBvbmVudCB2aWV3cyBzaG91bGQgZXhpc3QuJyk7XG4gIGFzc2VydERlZmluZWQoXG4gICAgICBsVmlld1tERUNMQVJBVElPTl9DT01QT05FTlRfVklFV11bVF9IT1NUXSEucHJvamVjdGlvbixcbiAgICAgIGVyck1lc3NhZ2UgfHxcbiAgICAgICAgICAnQ29tcG9uZW50cyB3aXRoIHByb2plY3Rpb24gbm9kZXMgKDxuZy1jb250ZW50PikgbXVzdCBoYXZlIHByb2plY3Rpb24gc2xvdHMgZGVmaW5lZC4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFBhcmVudFZpZXcobFZpZXc6IExWaWV3fG51bGwsIGVyck1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgYXNzZXJ0RGVmaW5lZChcbiAgICAgIGxWaWV3LFxuICAgICAgZXJyTWVzc2FnZSB8fCAnQ29tcG9uZW50IHZpZXdzIHNob3VsZCBhbHdheXMgaGF2ZSBhIHBhcmVudCB2aWV3IChjb21wb25lbnRcXCdzIGhvc3QgdmlldyknKTtcbn1cblxuXG4vKipcbiAqIFRoaXMgaXMgYSBiYXNpYyBzYW5pdHkgY2hlY2sgdGhhdCB0aGUgYGluamVjdG9ySW5kZXhgIHNlZW1zIHRvIHBvaW50IHRvIHdoYXQgbG9va3MgbGlrZSBhXG4gKiBOb2RlSW5qZWN0b3IgZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIGxWaWV3IGBMVmlld2Agd2hpY2ggc2hvdWxkIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gaW5qZWN0b3JJbmRleCBpbmRleCBpbnRvIHRoZSBgTFZpZXdgIHdoZXJlIHRoZSBgTm9kZUluamVjdG9yYCBpcyBleHBlY3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vZGVJbmplY3RvcihsVmlldzogTFZpZXcsIGluamVjdG9ySW5kZXg6IG51bWJlcikge1xuICBhc3NlcnRJbmRleEluRXhwYW5kb1JhbmdlKGxWaWV3LCBpbmplY3RvckluZGV4KTtcbiAgYXNzZXJ0SW5kZXhJbkV4cGFuZG9SYW5nZShsVmlldywgaW5qZWN0b3JJbmRleCArIE5vZGVJbmplY3Rvck9mZnNldC5QQVJFTlQpO1xuICBhc3NlcnROdW1iZXIobFZpZXdbaW5qZWN0b3JJbmRleCArIDBdLCAnaW5qZWN0b3JJbmRleCBzaG91bGQgcG9pbnQgdG8gYSBibG9vbSBmaWx0ZXInKTtcbiAgYXNzZXJ0TnVtYmVyKGxWaWV3W2luamVjdG9ySW5kZXggKyAxXSwgJ2luamVjdG9ySW5kZXggc2hvdWxkIHBvaW50IHRvIGEgYmxvb20gZmlsdGVyJyk7XG4gIGFzc2VydE51bWJlcihsVmlld1tpbmplY3RvckluZGV4ICsgMl0sICdpbmplY3RvckluZGV4IHNob3VsZCBwb2ludCB0byBhIGJsb29tIGZpbHRlcicpO1xuICBhc3NlcnROdW1iZXIobFZpZXdbaW5qZWN0b3JJbmRleCArIDNdLCAnaW5qZWN0b3JJbmRleCBzaG91bGQgcG9pbnQgdG8gYSBibG9vbSBmaWx0ZXInKTtcbiAgYXNzZXJ0TnVtYmVyKGxWaWV3W2luamVjdG9ySW5kZXggKyA0XSwgJ2luamVjdG9ySW5kZXggc2hvdWxkIHBvaW50IHRvIGEgYmxvb20gZmlsdGVyJyk7XG4gIGFzc2VydE51bWJlcihsVmlld1tpbmplY3RvckluZGV4ICsgNV0sICdpbmplY3RvckluZGV4IHNob3VsZCBwb2ludCB0byBhIGJsb29tIGZpbHRlcicpO1xuICBhc3NlcnROdW1iZXIobFZpZXdbaW5qZWN0b3JJbmRleCArIDZdLCAnaW5qZWN0b3JJbmRleCBzaG91bGQgcG9pbnQgdG8gYSBibG9vbSBmaWx0ZXInKTtcbiAgYXNzZXJ0TnVtYmVyKGxWaWV3W2luamVjdG9ySW5kZXggKyA3XSwgJ2luamVjdG9ySW5kZXggc2hvdWxkIHBvaW50IHRvIGEgYmxvb20gZmlsdGVyJyk7XG4gIGFzc2VydE51bWJlcihcbiAgICAgIGxWaWV3W2luamVjdG9ySW5kZXggKyBOb2RlSW5qZWN0b3JPZmZzZXQuUEFSRU5UXSxcbiAgICAgICdpbmplY3RvckluZGV4IHNob3VsZCBwb2ludCB0byBwYXJlbnQgaW5qZWN0b3InKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJDb21tZW50KG5hdGl2ZTogUk5vZGUsIGVyck1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgYXNzZXJ0RXF1YWwoXG4gICAgICAobmF0aXZlIGFzIEhUTUxFbGVtZW50KS5ub2RlVHlwZSwgTm9kZS5DT01NRU5UX05PREUsXG4gICAgICBlcnJNZXNzYWdlID8/ICdFeHBlY3RlZCB0aGlzIGVsZW1lbnQgdG8gYmUgYSBjb21tZW50IG5vZGUnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJFbGVtZW50KG5hdGl2ZTogUk5vZGUsIHRhZ05hbWU6IHN0cmluZywgZXJyTWVzc2FnZT86IHN0cmluZykge1xuICBhc3NlcnRFcXVhbChcbiAgICAgIChuYXRpdmUgYXMgSFRNTEVsZW1lbnQpLm5vZGVUeXBlLCBOb2RlLkVMRU1FTlRfTk9ERSxcbiAgICAgIGVyck1lc3NhZ2UgPz8gJ0V4cGVjdGVkIHRoaXMgZWxlbWVudCB0byBiZSBhbiBlbGVtZW50IG5vZGUnKTtcbiAgYXNzZXJ0RXF1YWwoXG4gICAgICAobmF0aXZlIGFzIEhUTUxFbGVtZW50KS50YWdOYW1lLnRvTG93ZXJDYXNlKCksIHRhZ05hbWUsXG4gICAgICBlcnJNZXNzYWdlID8/IGBFeHBlY3RlZCB0aGlzIGVsZW1lbnQgbm9kZSB0byBoYXZlIHRoZSAke3RhZ05hbWV9IHRhZyBuYW1lYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSVGV4dChuYXRpdmU6IFJOb2RlLCBlcnJNZXNzYWdlPzogc3RyaW5nKSB7XG4gIGFzc2VydEVxdWFsKFxuICAgICAgKG5hdGl2ZSBhcyBIVE1MRWxlbWVudCkubm9kZVR5cGUsIE5vZGUuVEVYVF9OT0RFLFxuICAgICAgZXJyTWVzc2FnZSA/PyAnRXhwZWN0ZWQgdGhpcyBlbGVtZW50IHRvIGJlIGEgdGV4dCBub2RlJyk7XG59XG4iXX0=